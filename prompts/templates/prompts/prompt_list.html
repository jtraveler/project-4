{% extends "base.html" %}
{% load static %}
{% load cloudinary_tags %}

{% block extra_head %}
<!-- Page-specific CSS -->
<link rel="stylesheet" href="{% static 'css/pages/prompt-list.css' %}">

<!-- Only preload the FIRST image for true LCP optimization -->
{% with first_prompt=prompt_list.0 %}
    {% if first_prompt and not "placeholder" in first_prompt.featured_image.url %}
        <link rel="preload" as="image" href="{{ first_prompt.featured_image.url|cloudinary_transform:'w_440,f_webp,q_90' }}" />
    {% endif %}
{% endwith %}
{% endblock %}

{% block content %}
<h1 class="visually-hidden">PromptFlow - AI Prompt Gallery and Community</h1>

<!-- Hidden CSRF token for AJAX requests -->
<div style="display: none;">
    {% csrf_token %}
</div>

<!-- Admin Controls Panel (only visible to staff) -->
{% if user.is_staff and show_admin_controls %}
<div class="admin-controls">
    <h4>
        <i class="fas fa-cog"></i>
        Admin Ordering Controls
    </h4>
    <p>
        You can reorder prompts using the up/down arrows on each card, drag & drop mode, or edit order numbers directly in the 
        <a href="/admin/prompts/prompt/" target="_blank" style="color: #fff; text-decoration: underline;">Django Admin</a>.
        New prompts appear at the top by default.
    </p>
    <div>
        <a href="/admin/prompts/prompt/" target="_blank" class="btn btn-sm">
            <i class="fas fa-external-link-alt"></i> Open Admin Panel
        </a>
        <button onclick="toggleOrderDisplay()" class="btn btn-sm" id="toggle-order-btn">
            <i class="fas fa-eye"></i> Show Order Numbers
        </button>
        <button onclick="toggleDragMode()" class="btn btn-sm" id="toggle-drag-btn">
            <i class="fas fa-arrows-alt"></i> Drag Mode
        </button>
    </div>
</div>
{% endif %}

<!-- Media Filter Tabs (Phase E) -->
<style>
.media-filter-container {
    background: white;
    border-bottom: 1px solid #e5e7eb;
    padding: 0 40px;
    margin: 0 auto;
    margin-bottom: 0;
    max-width: 1600px;
    width: 100%;
}

.media-filter-tabs {
    display: flex;
    gap: 0;
}

.media-tab {
    padding: 12px 24px;
    background: none;
    border: none;
    border-bottom: 3px solid transparent;
    color: #6b7280;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    text-decoration: none;
}

.media-tab:hover {
    color: #1f2937;
    background: #f9fafb;
}

.media-tab.active {
    color: #1d4ed8;  /* Darker blue for WCAG AA contrast (4.5:1 minimum) */
    border-bottom-color: #1d4ed8;
}

@media (max-width: 768px) {
    .media-filter-container {
        padding: 0 20px;
    }

    .media-tab {
        flex: 1;
        padding: 12px 8px;
        font-size: 14px;
        text-align: center;
    }
}

/* Mobile padding fix for very small screens (iPhone SE, etc.) */
@media (max-width: 400px) {
    .media-filter-container {
        padding: 0 12px;  /* Reduced from 20px to prevent horizontal scrollbar */
    }
}

/* ============================================
   SORT DROPDOWN FILTER (Pexels-style)
   Phase G Implementation
   ============================================ */

.filter-bar-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: white;
    border-bottom: 1px solid #e5e7eb;
    padding: 0 40px;
    margin: 0 auto;
    max-width: 1600px;
    width: 100%;
}

.sort-dropdown {
    position: relative;
    display: inline-block;
}

.sort-dropdown-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 16px;
    font-size: 15px;
    font-weight: 500;
    color: #1a1a1a;
    background-color: #ffffff;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.sort-dropdown-btn:hover {
    border-color: #666;
}

.sort-dropdown-btn:focus {
    outline: none;
    border-color: #262626;
    box-shadow: 0 0 0 2px rgba(38, 38, 38, 0.1);
}

.sort-dropdown-chevron {
    transition: transform 0.2s ease;
}

.sort-dropdown.open .sort-dropdown-chevron {
    transform: rotate(180deg);
}

.sort-dropdown-menu {
    position: absolute;
    top: calc(100% + 4px);
    left: 0;
    min-width: 160px;
    padding: 8px 0;
    background-color: #ffffff;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    opacity: 0;
    visibility: hidden;
    transform: translateY(-8px);
    transition: all 0.2s ease;
    z-index: 100;
}

.sort-dropdown.open .sort-dropdown-menu {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
}

.sort-dropdown-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 16px;
    font-size: 14px;
    color: #1a1a1a;
    text-decoration: none;
    transition: background-color 0.15s ease;
}

.sort-dropdown-item:hover {
    background-color: #f5f5f5;
    text-decoration: none;
    color: #1a1a1a;
}

/* Focus state for keyboard accessibility (WCAG 2.1 Level AA) */
.sort-dropdown-item:focus {
    outline: 2px solid #262626;
    outline-offset: -2px;
    background-color: #f5f5f5;
}

.sort-dropdown-item.active {
    font-weight: 600;
}

.sort-check-icon {
    color: #262626;
    flex-shrink: 0;
}

/* Empty state for Following filter */
.empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 80px 20px;
    text-align: center;
    max-width: 400px;
    margin: 0 auto;
}

.empty-state-icon {
    color: #999;
    margin-bottom: 20px;
}

.empty-state-title {
    font-size: 20px;
    font-weight: 600;
    color: #1a1a1a;
    margin: 0 0 12px 0;
}

.empty-state-text {
    font-size: 15px;
    color: #666;
    margin: 0 0 24px 0;
    line-height: 1.5;
}

.empty-state-btn {
    display: inline-flex;
    align-items: center;
    padding: 12px 24px;
    font-size: 14px;
    font-weight: 500;
    color: #fff;
    background-color: #262626;
    border-radius: 8px;
    text-decoration: none;
    transition: background-color 0.2s ease;
}

.empty-state-btn:hover {
    background-color: #404040;
    color: #fff;
    text-decoration: none;
}

@media (max-width: 768px) {
    .filter-bar-container {
        padding: 0 20px;
    }

    .sort-dropdown-btn {
        padding: 8px 12px;
        font-size: 14px;
    }

    .sort-dropdown-menu {
        min-width: 140px;
    }
}

@media (max-width: 400px) {
    .filter-bar-container {
        padding: 0 12px;
    }
}
</style>

<!-- Filter Bar: Sort Dropdown + Media Tabs (Phase G) -->
<div class="filter-bar-container">
    <!-- Sort Dropdown (Left) -->
    <div class="sort-dropdown" id="sortDropdown">
        <button class="sort-dropdown-btn" id="sortDropdownBtn" aria-haspopup="true" aria-expanded="false">
            {% if sort_by == 'new' %}
                New
            {% elif sort_by == 'following' %}
                Following
            {% else %}
                Trending
            {% endif %}
            <svg class="sort-dropdown-chevron" width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M2.5 4.5L6 8L9.5 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </button>
        <div class="sort-dropdown-menu" id="sortDropdownMenu" role="menu">
            <a href="{% url 'prompts:home' %}?sort=trending{% if media_filter != 'all' %}&media={{ media_filter }}{% endif %}{% if current_tag %}&tag={{ current_tag }}{% endif %}{% if search_query %}&search={{ search_query }}{% endif %}"
               class="sort-dropdown-item {% if sort_by == 'trending' %}active{% endif %}"
               role="menuitem">
                {% if sort_by == 'trending' %}
                <svg class="sort-check-icon" width="16" height="16" viewBox="0 0 16 16" fill="none">
                    <path d="M13.5 4.5L6 12L2.5 8.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                {% else %}
                <span style="width: 16px;"></span>
                {% endif %}
                Trending
            </a>
            <a href="{% url 'prompts:home' %}?sort=new{% if media_filter != 'all' %}&media={{ media_filter }}{% endif %}{% if current_tag %}&tag={{ current_tag }}{% endif %}{% if search_query %}&search={{ search_query }}{% endif %}"
               class="sort-dropdown-item {% if sort_by == 'new' %}active{% endif %}"
               role="menuitem">
                {% if sort_by == 'new' %}
                <svg class="sort-check-icon" width="16" height="16" viewBox="0 0 16 16" fill="none">
                    <path d="M13.5 4.5L6 12L2.5 8.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                {% else %}
                <span style="width: 16px;"></span>
                {% endif %}
                New
            </a>
            {% if user.is_authenticated %}
            <a href="{% url 'prompts:home' %}?sort=following{% if media_filter != 'all' %}&media={{ media_filter }}{% endif %}{% if current_tag %}&tag={{ current_tag }}{% endif %}{% if search_query %}&search={{ search_query }}{% endif %}"
               class="sort-dropdown-item {% if sort_by == 'following' %}active{% endif %}"
               role="menuitem">
                {% if sort_by == 'following' %}
                <svg class="sort-check-icon" width="16" height="16" viewBox="0 0 16 16" fill="none">
                    <path d="M13.5 4.5L6 12L2.5 8.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                {% else %}
                <span style="width: 16px;"></span>
                {% endif %}
                Following
            </a>
            {% endif %}
        </div>
    </div>

    <!-- Media Filter Tabs (Right) -->
    <div class="media-filter-tabs" role="tablist" aria-label="Filter prompts by media type">
        <a href="{% url 'prompts:home' %}?media=all{% if sort_by and sort_by != 'trending' %}&sort={{ sort_by }}{% endif %}{% if current_tag %}&tag={{ current_tag }}{% endif %}{% if search_query %}&search={{ search_query }}{% endif %}"
           class="media-tab {% if media_filter == 'all' %}active{% endif %}"
           role="tab"
           aria-selected="{% if media_filter == 'all' %}true{% else %}false{% endif %}">
            All
        </a>
        <a href="{% url 'prompts:home' %}?media=photos{% if sort_by and sort_by != 'trending' %}&sort={{ sort_by }}{% endif %}{% if current_tag %}&tag={{ current_tag }}{% endif %}{% if search_query %}&search={{ search_query }}{% endif %}"
           class="media-tab {% if media_filter == 'photos' %}active{% endif %}"
           role="tab"
           aria-selected="{% if media_filter == 'photos' %}true{% else %}false{% endif %}">
            <i class="fas fa-image"></i> Photos
        </a>
        <a href="{% url 'prompts:home' %}?media=videos{% if sort_by and sort_by != 'trending' %}&sort={{ sort_by }}{% endif %}{% if current_tag %}&tag={{ current_tag }}{% endif %}{% if search_query %}&search={{ search_query }}{% endif %}"
           class="media-tab {% if media_filter == 'videos' %}active{% endif %}"
           role="tab"
           aria-selected="{% if media_filter == 'videos' %}true{% else %}false{% endif %}">
            <i class="fas fa-video"></i> Videos
        </a>
    </div>
</div>

<!-- Tag Filter Header -->
{% if current_tag %}
<div class="tag-filter-header">
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-md-8 text-center">
                <h2 class="tag-title">
                    Showing prompts tagged with: <span class="tag-name">"{{ current_tag }}"</span>
                </h2>
                <p class="tag-subtitle">{{ page_obj.paginator.count }} prompt{{ page_obj.paginator.count|pluralize }} found</p>
                <a href="{% url 'prompts:home' %}#browse-prompts" class="btn btn-outline-primary btn-sm">
                    <i class="fas fa-arrow-left me-1"></i> Show all prompts
                </a>
            </div>
        </div>
    </div>
</div>
{% endif %}

<!-- Enhanced Search Results Header -->
{% if search_query %}
<div class="tag-filter-header">
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-md-10 text-center">
                <h2 class="tag-title">
                    <i class="fas fa-search me-2"></i>Search results for: <span class="tag-name">"{{ search_query }}"</span>
                </h2>
                <p class="tag-subtitle">
                    {{ page_obj.paginator.count }} prompt{{ page_obj.paginator.count|pluralize }} found
                    {% if page_obj.paginator.count > 0 %}
                        <br>
                        <small class="text-muted">
                            Searched in: titles, content, descriptions, authors, and tags
                        </small>
                    {% endif %}
                </p>
                <div class="search-actions mt-3">
                    <a href="{% url 'prompts:home' %}#browse-prompts" class="btn btn-outline-primary btn-sm">
                        <i class="fas fa-arrow-left me-1"></i> Show all prompts
                    </a>
                </div>
            </div>
        </div>
    </div>
</div>
{% endif %}

<!-- Check if we have prompts to show -->
{% if prompt_list %}
<!-- Optimized masonry grid -->
<div class="masonry-container">
    <div class="masonry-wrapper">
        <div class="masonry-grid" id="masonry-grid">
            <!-- Columns will be created by JavaScript -->
        </div>
    </div>
    
    <!-- Store items in a hidden container for JavaScript to process -->
    <div id="items-container" style="display: none;">
        {% for prompt in prompt_list %}
            {% include 'prompts/partials/_prompt_card.html' with prompt=prompt show_trash_actions=False show_admin_controls=True %}
        {% endfor %}
    </div>
    
    <!-- Load More Button -->
    {% if page_obj.has_next %}
    <div class="load-more-container text-center mt-5 mb-5">
        <button id="load-more-btn"
                class="btn btn-primary btn-lg"
                data-next-page="{{ page_obj.next_page_number }}"
                aria-label="Load more prompts">
            <i class="fas fa-plus-circle me-2"></i>
            Load More Prompts
        </button>
    </div>
    {% else %}
    <!-- End of results message -->
    <div class="end-of-results text-center mt-5">
        <div class="end-message">
            <i class="fas fa-check-circle text-muted mb-3" style="font-size: 3rem;"></i>
            <h3 class="text-muted">You have reached the end.</h3>
            <p class="text-muted">No more prompts to load</p>
        </div>
    </div>
    {% endif %}
</div>
{% else %}
<!-- No results message - Outside masonry container -->
{% if sort_by == 'following' and following_count == 0 %}
<!-- Special empty state: User follows no one -->
<div class="empty-state">
    <div class="empty-state-icon">
        <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
            <circle cx="9" cy="7" r="4"></circle>
            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
        </svg>
    </div>
    <h3 class="empty-state-title">Start following creators</h3>
    <p class="empty-state-text">
        Follow your favorite prompt creators to see their latest work here.
        Discover trending prompts to find creators you'll love.
    </p>
    <a href="{% url 'prompts:home' %}?sort=trending" class="empty-state-btn">
        Browse Trending Prompts
    </a>
</div>
{% elif sort_by == 'following' %}
<!-- User follows people but no prompts from them -->
<div class="empty-state">
    <div class="empty-state-icon">
        <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <circle cx="8.5" cy="8.5" r="1.5"></circle>
            <polyline points="21 15 16 10 5 21"></polyline>
        </svg>
    </div>
    <h3 class="empty-state-title">No prompts yet</h3>
    <p class="empty-state-text">
        The creators you follow haven't shared any prompts yet.
        Check back later or discover new creators.
    </p>
    <a href="{% url 'prompts:home' %}?sort=trending" class="empty-state-btn">
        Browse Trending Prompts
    </a>
</div>
{% elif sort_by == 'trending' %}
<!-- No trending prompts in last 7 days -->
<div class="empty-state">
    <div class="empty-state-icon">
        <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"></path>
        </svg>
    </div>
    <h3 class="empty-state-title">No trending prompts</h3>
    <p class="empty-state-text">
        There are no trending prompts from the last 7 days.
        Browse all new prompts instead.
    </p>
    <a href="{% url 'prompts:home' %}?sort=new" class="empty-state-btn">
        Browse New Prompts
    </a>
</div>
{% else %}
<!-- Generic empty state -->
<div class="container">
    <div class="row justify-content-center">
        <div class="col-md-6 text-center py-5">
            <h2 class="text-muted mb-3">No prompts found</h2>
            <p class="text-muted">Try adjusting your search or browse all prompts</p>
        </div>
    </div>
</div>
{% endif %}
{% endif %}

<!-- Sticky Save Panel (only visible to staff when changes are made) -->
{% if user.is_staff %}
<div class="sticky-save-panel" id="sticky-save-panel">
    <h5><i class="fas fa-save me-2"></i>Unsaved Changes</h5>
    <div class="changes-count" id="changes-count">0 items reordered</div>
    <div>
        <button onclick="saveOrderChanges()" class="btn btn-save">
            <i class="fas fa-check me-1"></i>Save Changes
        </button>
        <button onclick="cancelOrderChanges()" class="btn">
            <i class="fas fa-times me-1"></i>Cancel
        </button>
    </div>
</div>
{% endif %}
{% endblock %}

{% block extras %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Masonry column management
    let columns = [];
    let columnCount = 4;
    let videoObserver = null;
    
    function getColumnCount() {
        const width = window.innerWidth;
        if (width < 500) return 1;
        if (width < 800) return 2;
        if (width < 1100) return 3;
        return 4;
    }
    
    function createColumns() {
        const grid = document.getElementById('masonry-grid');
        grid.innerHTML = '';
        columns = [];
        
        const newColumnCount = getColumnCount();
        grid.setAttribute('data-columns', newColumnCount);
        
        for (let i = 0; i < 4; i++) { // Always create 4 columns, CSS will hide extras
            const column = document.createElement('div');
            column.className = 'masonry-column';
            column.id = `column-${i}`;
            grid.appendChild(column);
            columns.push(column);
        }
        
        columnCount = newColumnCount;
    }
    
    function getShortestColumn() {
        let shortest = columns[0];
        let minHeight = shortest.offsetHeight;
        
        for (let i = 0; i < columnCount; i++) {
            if (columns[i].offsetHeight < minHeight) {
                minHeight = columns[i].offsetHeight;
                shortest = columns[i];
            }
        }
        
        return shortest;
    }
    
    // Find the shortest column starting from a specific index
    function getShortestColumnFrom(startIndex) {
        let shortestIndex = startIndex;
        let minHeight = columns[startIndex].offsetHeight;
        
        // Check columns in order from startIndex
        for (let i = startIndex; i < columnCount; i++) {
            if (columns[i].offsetHeight < minHeight) {
                minHeight = columns[i].offsetHeight;
                shortestIndex = i;
            }
        }
        
        // If we didn't find a shorter column to the right, check from the beginning
        for (let i = 0; i < startIndex; i++) {
            if (columns[i].offsetHeight < minHeight) {
                minHeight = columns[i].offsetHeight;
                shortestIndex = i;
            }
        }
        
        return columns[shortestIndex];
    }

    /**
     * FORCED EQUAL DISTRIBUTION - For initial page load only
     * Distributes items as evenly as possible across columns
     */
    function forceEqualDistribution(items) {
        const currentColumns = Array.from(document.querySelectorAll('.masonry-column'));
        
        if (currentColumns.length === 0) {
            console.error('No columns found for redistribution');
            return;
        }
        
        // Clear all columns
        currentColumns.forEach(column => column.innerHTML = '');
        
        const activeColumns = currentColumns.slice(0, columnCount);
        const itemsPerColumn = Math.ceil(items.length / columnCount);
        
        console.log(`Equal distribution: ${items.length} items across ${columnCount} columns (max ${itemsPerColumn} items per column)`);
        
        // Distribute items evenly - each column gets roughly the same number
        let currentColumnIndex = 0;
        let itemsInCurrentColumn = 0;
        
        items.forEach((item, index) => {
            // If current column is full, move to next column
            if (itemsInCurrentColumn >= itemsPerColumn && currentColumnIndex < columnCount - 1) {
                currentColumnIndex++;
                itemsInCurrentColumn = 0;
            }
            
            activeColumns[currentColumnIndex].appendChild(item);
            itemsInCurrentColumn++;
            
            console.log(`Item ${index + 1} -> Column ${currentColumnIndex + 1} (${itemsInCurrentColumn}/${itemsPerColumn})`);
        });
        
        // Log final distribution
        activeColumns.forEach((column, index) => {
            console.log(`Column ${index + 1}: ${column.children.length} items`);
        });
    }

    /**
     * HYBRID REDISTRIBUTION - For drag operations
     * Provides immediate visual feedback while maintaining reasonable balance
     */
    function hybridRedistribution(items) {
        const currentColumns = Array.from(document.querySelectorAll('.masonry-column'));
        
        if (currentColumns.length === 0) {
            console.error('No columns found for redistribution');
            return;
        }
        
        // Clear all columns
        currentColumns.forEach(column => column.innerHTML = '');
        const activeColumns = currentColumns.slice(0, columnCount);
        
        console.log('Hybrid redistribution: respects drag order with balance limits');
        
        // Track column stats
        const columnStats = activeColumns.map((column, index) => ({
            element: column,
            itemCount: 0,
            index: index
        }));
        
        const maxItemsPerColumn = Math.ceil(items.length / columnCount) + 1; // Allow some flexibility
        
        items.forEach((item, index) => {
            // First preference: shortest column (for visual balance)
            let targetColumnIndex = 0;
            let minItems = columnStats[0].itemCount;
            
            for (let i = 0; i < columnCount; i++) {
                if (columnStats[i].itemCount < minItems) {
                    minItems = columnStats[i].itemCount;
                    targetColumnIndex = i;
                }
            }
            
            // If shortest column is getting too full, use round-robin
            if (columnStats[targetColumnIndex].itemCount >= maxItemsPerColumn) {
                targetColumnIndex = index % columnCount;
            }
            
            // Add item to selected column
            const targetColumn = columnStats[targetColumnIndex];
            targetColumn.element.appendChild(item);
            targetColumn.itemCount++;
            
            console.log(`Item ${index + 1} -> Column ${targetColumnIndex + 1} (${targetColumn.itemCount} items)`);
        });
        
        // Log final distribution
        columnStats.forEach((stat) => {
            console.log(`Column ${stat.index + 1}: ${stat.itemCount} items`);
        });
        
        // Re-enable dragging if drag mode is active
        if (typeof dragModeEnabled !== 'undefined' && dragModeEnabled) {
            items.forEach(item => enableDragging(item));
        }
        
        // Reinitialize video observer
        initVideoObserver();
    }

    // FIXED distribute items function - hybrid approach for different scenarios
    function distributeItems(items, animate = false, preferLeftToRight = false) {
        console.log(`distributeItems called with ${items.length} items, animate: ${animate}, preferLeftToRight: ${preferLeftToRight}`);
        
        if (preferLeftToRight) {
            // For "Load More" items, use the original left-to-right logic to append naturally
            // This preserves the smooth load more UX without rebuilding the entire grid
            console.log('Using original append logic for load more items');
            
            // Simple left-to-right distribution for load more
            let currentColumnIndex = 0;
            
            items.forEach((item, index) => {
                if (animate) {
                    item.classList.add('new-item');
                    item.style.animationDelay = `${index * 0.1}s`;
                }
                
                // Add to current column and move to next
                columns[currentColumnIndex].appendChild(item);
                currentColumnIndex = (currentColumnIndex + 1) % columnCount;
                
                console.log(`Load more item ${index + 1} -> Column ${currentColumnIndex}`);
            });
        } else {
            // For initial load only, use equal distribution for better balance
            console.log('Using equal distribution for initial load');
            forceEqualDistribution(items);
            
            // Apply animations if requested
            if (animate) {
                items.forEach((item, index) => {
                    item.classList.add('new-item');
                    item.style.animationDelay = `${index * 0.1}s`;
                });
            }
        }
        
        // Initialize video observer after items are distributed
        initVideoObserver();
    }


    /**
     * Lazy-loads video content by setting the source URL only when needed.
     * This improves page load performance by deferring video loading until
     * the video enters the viewport.
     * 
     * @param {HTMLVideoElement} video - The video element to load
     * @returns {void} Early returns if video is already loaded
     */
    function loadVideoSource(video) {
        if (video.dataset.loaded === 'true') return;
        
        const source = video.querySelector('source');
        if (source && source.dataset.src) {
            source.src = source.dataset.src;
            video.load();
            video.dataset.loaded = 'true';
        }
    }

// Video auto-play functionality with lazy loading

function initVideoObserver() {
    if (videoObserver) {
        videoObserver.disconnect();
    }
    
    const videoCards = document.querySelectorAll('[data-video="true"]');
    
    if (videoCards.length === 0) return;
    
    // Check if mobile or prefers reduced motion
    const isMobile = window.innerWidth <= 768;
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    
    if (isMobile || prefersReducedMotion) {
        return; // Skip video autoplay on mobile or reduced motion preference
    }
    
    // Percentage-based offsets
    const PAUSE_OFFSET_PERCENT = 0.5; // 50% of video height must be visible
    const PLAY_OFFSET_PERCENT = 0.3;  // 30% of video height
    
    // Store play promises to handle them properly
    const playPromises = new WeakMap();
    
    videoObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            const video = entry.target.querySelector('video');
            const thumbnail = entry.target.querySelector('.video-thumbnail');
            const playIcon = entry.target.querySelector('.video-play-icon');
            
            if (!video) return;
            
            // Get the element's position relative to viewport
            const rect = entry.boundingClientRect;
            const viewportHeight = window.innerHeight;
            const elementHeight = rect.height;
            
            // Calculate dynamic offsets based on element height
            const playOffset = elementHeight * PLAY_OFFSET_PERCENT;
            
            // Check if video is already initialized
            const isInitialized = video.dataset.initialized === 'true';
            
            if (entry.isIntersecting && entry.intersectionRatio > 0.3) {
                // Check if we should play based on percentage offsets
                const topInView = rect.top < viewportHeight - playOffset;
                const bottomInView = rect.bottom > playOffset;
                const shouldPlay = topInView && bottomInView;
                
                if (shouldPlay || !isInitialized) {
                    // Load video source if not already loaded
                    loadVideoSource(video);
                    
                    // First time setup - show video once
                    if (!isInitialized) {
                        video.style.display = 'block';
                        video.style.visibility = 'visible';
                        video.dataset.initialized = 'true';
                    }
                    
                    // Only play if not already playing
                    if (video.paused) {
                        if (thumbnail) thumbnail.style.opacity = '0';
                        if (playIcon) playIcon.style.opacity = '0';
                        
                        // Store and handle the play promise properly
                        const playPromise = video.play();
                        
                        if (playPromise !== undefined) {
                            playPromises.set(video, playPromise);
                            
                            playPromise
                                .then(() => {
                                    // Playback started successfully
                                    playPromises.delete(video);
                                })
                                .catch(error => {
                                    // Only log if it's not an AbortError
                                    if (error.name !== 'AbortError') {
                                        console.log('Auto-play prevented:', error);
                                        if (thumbnail) thumbnail.style.opacity = '1';
                                        if (playIcon) playIcon.style.opacity = '1';
                                    }
                                    playPromises.delete(video);
                                });
                        }
                    }
                }
            }
            
            // Always check pause conditions for initialized videos
            if (isInitialized) {
                // Calculate how much is visible when scrolling out
                const topVisible = rect.top >= 0 && rect.top < viewportHeight;
                const bottomVisible = rect.bottom > 0 && rect.bottom <= viewportHeight;
                
                let shouldPause = false;
                
                if (!entry.isIntersecting) {
                    shouldPause = true;
                } else if (topVisible && !bottomVisible) {
                    // Scrolling up, video going out bottom
                    const visiblePortion = (viewportHeight - rect.top) / elementHeight;
                    shouldPause = visiblePortion < PAUSE_OFFSET_PERCENT;
                } else if (!topVisible && bottomVisible) {
                    // Scrolling down, video going out top
                    const visiblePortion = rect.bottom / elementHeight;
                    shouldPause = visiblePortion < PAUSE_OFFSET_PERCENT;
                }
                
                if (shouldPause && !video.paused) {
                    // Wait for any pending play promise before pausing
                    const currentPlayPromise = playPromises.get(video);
                    
                    if (currentPlayPromise) {
                        currentPlayPromise.then(() => {
                            video.pause();
                        }).catch(() => {
                            // Ignore the error, video wasn't playing anyway
                        });
                    } else {
                        video.pause();
                    }
                }
            }
        });
    }, {
        threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1],
        rootMargin: '0px'
    });
    
    videoCards.forEach(card => {
        videoObserver.observe(card);
    });
    
    // Force initial check for videos already in view
    setTimeout(() => {
        videoCards.forEach(card => {
            const rect = card.getBoundingClientRect();
            const video = card.querySelector('video');
            const thumbnail = card.querySelector('.video-thumbnail');
            const playIcon = card.querySelector('.video-play-icon');
            
            if (rect.top < window.innerHeight && rect.bottom > 0 && video) {
                // Video is in view on load
                loadVideoSource(video);
                video.style.display = 'block';
                video.style.visibility = 'visible';
                video.dataset.initialized = 'true';
                
                if (thumbnail) thumbnail.style.opacity = '0';
                if (playIcon) playIcon.style.opacity = '0';
                
                const playPromise = video.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        if (error.name !== 'AbortError') {
                            console.log('Initial auto-play prevented:', error);
                            if (thumbnail) thumbnail.style.opacity = '1';
                            if (playIcon) playIcon.style.opacity = '1';
                        }
                    });
                }
            }
        });
    }, 500);
}
    
    // Initialize columns
    createColumns();
    
    // Distribute initial items
    const itemsContainer = document.getElementById('items-container');
    const initialItems = Array.from(itemsContainer.querySelectorAll('[data-item]'));
    distributeItems(initialItems, false, false);
    
    // Heart functionality
    function attachHeartFunctionality(container = document) {
        const likeSections = container.querySelectorAll('.like-section');
        
        likeSections.forEach(function(section) {
            if (section.dataset.listenerAttached) return;
            
            section.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const promptSlug = this.getAttribute('data-prompt-slug');
                const heartIcon = this.querySelector('i');
                const likeCount = this.querySelector('.like-count');
                const likePlural = this.querySelector('.like-plural');
                
                fetch('/prompt/' + promptSlug + '/like/', {
                    method: 'POST',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                        'Content-Type': 'application/json',
                    },
                })
                .then(response => response.json())
                .then(data => {
                    likeCount.textContent = data.like_count;
                    likePlural.textContent = data.like_count === 1 ? '' : 's';
                    heartIcon.className = data.liked ? 'fas fa-heart me-1' : 'far fa-heart me-1';
                    heartIcon.style.color = 'white';
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Something went wrong. Please try again.');
                });
            });
            
            section.dataset.listenerAttached = 'true';
        });
    }
    
    attachHeartFunctionality();
    
    // Load More functionality
    const loadMoreBtn = document.getElementById('load-more-btn');

    if (loadMoreBtn) {
        loadMoreBtn.addEventListener('click', function() {
            const nextPage = this.getAttribute('data-next-page');
            const currentUrl = window.location.pathname;
            const currentParams = new URLSearchParams(window.location.search);
            currentParams.set('page', nextPage);

            // Disable button and show loading state (prevents jumping)
            loadMoreBtn.disabled = true;
            loadMoreBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Loading More Prompts...';
            loadMoreBtn.style.pointerEvents = 'none';  // Prevent additional clicks
            
            // Hide all order numbers temporarily if they're currently visible
            const wasOrderVisible = orderDisplayVisible;
            if (wasOrderVisible) {
                // Just hide numbers, don't toggle the state
                document.querySelectorAll('.order-display').forEach(display => {
                    display.style.display = 'none';
                });
            }
            
            // Build fetch URL properly
            const fetchUrl = `${currentUrl}?${currentParams.toString()}`;
            console.log('üîç LOAD MORE DEBUG:');
            console.log('  Next page:', nextPage);
            console.log('  Current URL:', currentUrl);
            console.log('  Params:', currentParams.toString());
            console.log('  Final fetch URL:', fetchUrl);

            fetch(fetchUrl)
                .then(response => {
                    console.log('  ‚úì Response received:', response.status, response.statusText);
                    console.log('  Response headers:', {
                        contentType: response.headers.get('content-type'),
                        contentLength: response.headers.get('content-length')
                    });

                    // Check if response is OK (status 200-299)
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(html => {
                    console.log('  ‚úì HTML received, length:', html.length);

                    const parser = new DOMParser();
                    const newDoc = parser.parseFromString(html, 'text/html');
                    const newItems = Array.from(newDoc.querySelectorAll('[data-item]'));

                    console.log('  ‚úì Parsed HTML, found items:', newItems.length);

                    // Safety check: Verify we got items
                    if (newItems.length === 0) {
                        console.warn('  ‚ö†Ô∏è  No items found in response - might be at end of results');
                        // If no items found, check if there's an error message in the response
                        const errorMsg = newDoc.querySelector('.alert-danger, .error-message');
                        if (errorMsg) {
                            console.error('  ‚ùå Error in response:', errorMsg.textContent);
                            throw new Error('Server returned an error: ' + errorMsg.textContent.trim());
                        }
                    }

                    // Distribute new items with left-to-right preference
                    console.log('  ‚Üí Distributing items...');
                    try {
                        distributeItems(newItems, true, true);
                        console.log('  ‚úì Items distributed successfully');
                    } catch (e) {
                        console.error('  ‚ùå Error in distributeItems:', e);
                        throw e;
                    }

                    // Attach heart functionality to new items
                    console.log('  ‚Üí Attaching heart functionality...');
                    try {
                        attachHeartFunctionality();
                        console.log('  ‚úì Heart functionality attached');
                    } catch (e) {
                        console.error('  ‚ùå Error in attachHeartFunctionality:', e);
                        throw e;
                    }

                    // Apply drag functionality to new items if drag mode is enabled
                    if (typeof dragModeEnabled !== 'undefined' && dragModeEnabled) {
                        console.log('  ‚Üí Applying drag functionality...');
                        try {
                            newItems.forEach(item => {
                                enableDragging(item);
                                // Show drag handles for new items
                                const dragHandle = item.querySelector('.drag-handle');
                                if (dragHandle) {
                                    dragHandle.classList.add('visible');
                                }
                            });
                            console.log('  ‚úì Drag functionality applied');
                        } catch (e) {
                            console.error('  ‚ùå Error in drag functionality:', e);
                            throw e;
                        }
                    }

                    // Show order numbers again if they were visible before
                    if (wasOrderVisible) {
                        setTimeout(() => {
                            // Force show all order displays including new ones
                            document.querySelectorAll('.order-display').forEach(display => {
                                display.style.display = 'block';
                            });
                            orderDisplayVisible = true;

                            // Update button text
                            const toggleBtn = document.getElementById('toggle-order-btn');
                            if (toggleBtn) {
                                toggleBtn.innerHTML = '<i class="fas fa-eye-slash"></i> Hide Order Numbers';
                            }
                        }, 300);
                    }

                    // Update load more button
                    console.log('  ‚Üí Updating Load More button...');
                    const newLoadMoreBtn = newDoc.getElementById('load-more-btn');
                    if (newLoadMoreBtn) {
                        console.log('  ‚úì More pages available, next page:', newLoadMoreBtn.getAttribute('data-next-page'));
                        // More pages available - restore button
                        loadMoreBtn.setAttribute('data-next-page',
                            newLoadMoreBtn.getAttribute('data-next-page'));
                        loadMoreBtn.disabled = false;
                        loadMoreBtn.innerHTML = '<i class="fas fa-plus-circle me-2"></i>Load More Prompts';
                        loadMoreBtn.style.pointerEvents = 'auto';
                    } else {
                        console.log('  ‚úì No more pages - showing end message');
                        // No more pages - replace with end message
                        const loadMoreContainer = document.querySelector('.load-more-container');
                        if (loadMoreContainer) {
                            loadMoreContainer.innerHTML = `
                                <div class="end-of-results text-center">
                                    <div class="end-message">
                                        <i class="fas fa-check-circle text-muted mb-3" style="font-size: 3rem;"></i>
                                        <h3 class="text-muted">You have reached the end.</h3>
                                        <p class="text-muted">No more prompts to load</p>
                                    </div>
                                </div>
                            `;
                        }
                    }

                    console.log('‚úÖ LOAD MORE COMPLETED SUCCESSFULLY');
                })
                .catch(error => {
                    console.error('‚ùå LOAD MORE ERROR:');
                    console.error('  Error type:', error.name);
                    console.error('  Error message:', error.message);
                    console.error('  Error stack:', error.stack);

                    // Restore button on error
                    loadMoreBtn.disabled = false;
                    loadMoreBtn.innerHTML = '<i class="fas fa-plus-circle me-2"></i>Load More Prompts';
                    loadMoreBtn.style.pointerEvents = 'auto';

                    // Show detailed error message to user
                    const errorDetail = error.message || 'Unknown error';
                    alert(`Failed to load more prompts.\n\nError: ${errorDetail}\n\nPlease check the browser console for details and try again.`);
                });
        });
    }
    
    // Tag filtering
    const tagBadges = document.querySelectorAll('.tag-clickable');
    tagBadges.forEach(function(badge) {
        badge.addEventListener('click', function() {
            const tagName = this.getAttribute('data-tag');
            const url = window.location.origin;
            window.location.href = `${url}/?tag=${encodeURIComponent(tagName)}`;
        });
    });
    
    // Handle window resize
    let resizeTimer;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(function() {
            if (getColumnCount() !== columnCount) {
                // Collect all items
                const allItems = [];
                columns.forEach(column => {
                    const items = Array.from(column.querySelectorAll('.masonry-item'));
                    allItems.push(...items);
                });
                
                // Recreate columns and redistribute
                createColumns();
                distributeItems(allItems, false, false);
            }
        }, 250);
    });
});


    /**
     * Redistribution for drag operations - provides immediate visual feedback
     */
     function redistributeItems() {
        // Collect all items and sort by order (this maintains drag order)
        const allItems = Array.from(document.querySelectorAll('.masonry-item'))
            .sort((a, b) => parseFloat(a.dataset.order) - parseFloat(b.dataset.order));
        
        console.log('Redistributing items after drag operation for immediate visual feedback...');
        
        // Get current column setup
        const currentColumns = Array.from(document.querySelectorAll('.masonry-column'));
        const activeColumnCount = currentColumns.filter(col => col.offsetParent !== null).length;
        
        console.log(`Total items: ${allItems.length}, Active columns: ${activeColumnCount}`);
        
        // Clear all columns first
        currentColumns.forEach(column => column.innerHTML = '');
        const activeColumns = currentColumns.slice(0, activeColumnCount);
        
        // Use simple round-robin distribution that respects the new order
        allItems.forEach((item, index) => {
            const targetColumnIndex = index % activeColumnCount;
            activeColumns[targetColumnIndex].appendChild(item);
            
            console.log(`Item ${index + 1} (order: ${item.dataset.order}) -> Column ${targetColumnIndex + 1}`);
        });
        
        // Re-enable dragging if drag mode is active
        if (typeof dragModeEnabled !== 'undefined' && dragModeEnabled) {
            allItems.forEach(item => enableDragging(item));
        }
        
        console.log('Drag redistribution complete - items should be in new visual positions');
    }


// Admin control functions (only available to staff)
{% if user.is_staff %}
let orderDisplayVisible = false;
let dragModeEnabled = false;
let pendingChanges = new Map(); // Map to store slug -> new order
let originalOrder = new Map(); // Map to store original order values

function toggleOrderDisplay() {
    const orderDisplays = document.querySelectorAll('.order-display');
    const toggleBtn = document.getElementById('toggle-order-btn');
    orderDisplayVisible = orderDisplays[0]?.style.display !== 'none';
    
    orderDisplays.forEach(display => {
        display.style.display = orderDisplayVisible ? 'none' : 'block';
    });
    
    // Update global state
    orderDisplayVisible = !orderDisplayVisible;
    
    if (toggleBtn) {
        const icon = toggleBtn.querySelector('i');
        const text = orderDisplayVisible ? 'Hide Order Numbers' : 'Show Order Numbers';
        toggleBtn.innerHTML = `<i class="fas fa-eye${orderDisplayVisible ? '-slash' : ''}"></i> ${text}`;
    }
}

function toggleDragMode() {
    dragModeEnabled = !dragModeEnabled;
    const toggleBtn = document.getElementById('toggle-drag-btn');
    const dragHandles = document.querySelectorAll('.drag-handle');
    
    dragHandles.forEach(handle => {
        handle.classList.toggle('visible', dragModeEnabled);
    });
    
    if (toggleBtn) {
        const icon = toggleBtn.querySelector('i');
        const text = dragModeEnabled ? 'Exit Drag Mode' : 'Drag Mode';
        const iconClass = dragModeEnabled ? 'fa-times' : 'fa-arrows-alt';
        toggleBtn.innerHTML = `<i class="fas ${iconClass}"></i> ${text}`;
        toggleBtn.style.background = dragModeEnabled ? 'rgba(220, 53, 69, 0.3)' : 'rgba(255, 255, 255, 0.2)';
    }
    
    // Enable/disable dragging
    const masonryItems = document.querySelectorAll('.masonry-item');
    masonryItems.forEach(item => {
        if (dragModeEnabled) {
            enableDragging(item);
        } else {
            disableDragging(item);
        }
    });
    
    // Show/hide order numbers automatically in drag mode
    if (dragModeEnabled && !orderDisplayVisible) {
        toggleOrderDisplay();
    }
}

// ENHANCED DRAG FUNCTIONALITY WITH BETTER VISUAL FEEDBACK
function enableDragging(item) {
    item.setAttribute('draggable', 'true');
    
    // Add event listeners to the item itself, not just the handle
    item.addEventListener('dragstart', handleDragStart);
    item.addEventListener('dragover', handleDragOver);
    item.addEventListener('drop', handleDrop);
    item.addEventListener('dragend', handleDragEnd);
    item.addEventListener('dragenter', handleDragEnter);
    item.addEventListener('dragleave', handleDragLeave);
}

function disableDragging(item) {
    item.setAttribute('draggable', 'false');
    item.removeEventListener('dragstart', handleDragStart);
    item.removeEventListener('dragover', handleDragOver);
    item.removeEventListener('drop', handleDrop);
    item.removeEventListener('dragend', handleDragEnd);
    item.removeEventListener('dragenter', handleDragEnter);
    item.removeEventListener('dragleave', handleDragLeave);
}

function handleDragStart(e) {
    if (!dragModeEnabled) return;
    
    const item = e.currentTarget;
    item.classList.add('dragging');
    e.dataTransfer.setData('text/plain', item.dataset.slug);
    e.dataTransfer.effectAllowed = 'move';
    
    // Store original order if not already stored
    if (!originalOrder.has(item.dataset.slug)) {
        originalOrder.set(item.dataset.slug, parseFloat(item.dataset.order));
    }
    
    console.log('Drag started for:', item.dataset.slug);
}

function handleDragEnter(e) {
    if (!dragModeEnabled) return;
    e.preventDefault();
}

function handleDragOver(e) {
    if (!dragModeEnabled) return;
    
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    const item = e.currentTarget;
    if (item && !item.classList.contains('dragging')) {
        item.classList.add('drag-over');
    }
}

function handleDragLeave(e) {
    if (!dragModeEnabled) return;
    
    const item = e.currentTarget;
    if (item) {
        item.classList.remove('drag-over');
    }
}

function handleDrop(e) {
    if (!dragModeEnabled) return;
    
    e.preventDefault();
    const draggedSlug = e.dataTransfer.getData('text/plain');
    const targetItem = e.currentTarget;
    const draggedItem = document.querySelector(`[data-slug="${draggedSlug}"]`);
    
    console.log('Drop event:', { draggedSlug, targetItem: targetItem.dataset.slug });
    
    if (targetItem && draggedItem && targetItem !== draggedItem) {
        // Calculate new order number
        const targetOrder = parseFloat(targetItem.dataset.order);
        
        // Determine if dropping above or below
        const rect = targetItem.getBoundingClientRect();
        const dropY = e.clientY;
        const targetCenter = rect.top + rect.height / 2;
        const isDroppedBelow = dropY > targetCenter;
        
        let newOrder;
        if (isDroppedBelow) {
            // Find next item's order to calculate between
            const nextOrder = getNextOrderAfter(targetOrder);
            newOrder = nextOrder ? (targetOrder + nextOrder) / 2 : targetOrder + 1;
        } else {
            // Find previous item's order to calculate between
            const prevOrder = getPreviousOrderBefore(targetOrder);
            newOrder = prevOrder ? (prevOrder + targetOrder) / 2 : targetOrder - 1;
        }
        
        console.log('New order calculated:', newOrder);
        
        // Update the order
        updateItemOrder(draggedSlug, newOrder);
        
        // Visual update
        draggedItem.dataset.order = newOrder;
        const orderDisplay = draggedItem.querySelector('.order-display');
        if (orderDisplay) {
            orderDisplay.textContent = newOrder.toFixed(1);
        }
        
        // Use the redistributeItems function from the correct scope
        if (typeof redistributeItems === 'function') {
            redistributeItems();
        } else {
            console.error('redistributeItems function not found in scope');
            // Fallback: force a page refresh to show changes
            location.reload();
        }
    }
    
    // Clean up
    document.querySelectorAll('.drag-over').forEach(item => {
        item.classList.remove('drag-over');
    });
}

function handleDragEnd(e) {
    const item = e.currentTarget;
    if (item) {
        item.classList.remove('dragging');
    }
    
    document.querySelectorAll('.drag-over').forEach(item => {
        item.classList.remove('drag-over');
    });
}

function getNextOrderAfter(order) {
    const items = Array.from(document.querySelectorAll('.masonry-item'))
        .map(item => parseFloat(item.dataset.order))
        .filter(o => o > order)
        .sort((a, b) => a - b);
    return items[0] || null;
}

function getPreviousOrderBefore(order) {
    const items = Array.from(document.querySelectorAll('.masonry-item'))
        .map(item => parseFloat(item.dataset.order))
        .filter(o => o < order)
        .sort((a, b) => b - a);
    return items[0] || null;
}

function updateItemOrder(slug, newOrder) {
    pendingChanges.set(slug, newOrder);
    updateSavePanel();
    console.log('Pending changes:', Array.from(pendingChanges.entries()));
}

function updateSavePanel() {
    const savePanel = document.getElementById('sticky-save-panel');
    const changesCount = document.getElementById('changes-count');
    
    if (pendingChanges.size > 0) {
        savePanel.classList.add('visible');
        changesCount.textContent = `${pendingChanges.size} item${pendingChanges.size !== 1 ? 's' : ''} reordered`;
    } else {
        savePanel.classList.remove('visible');
    }
}

function saveOrderChanges() {
    if (pendingChanges.size === 0) return;
    
    const saveBtn = document.querySelector('.btn-save');
    const originalText = saveBtn.innerHTML;
    saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Saving...';
    saveBtn.disabled = true;
    
    // Convert Map to array for AJAX
    const changes = Array.from(pendingChanges.entries()).map(([slug, order]) => ({
        slug: slug,
        order: order
    }));
    
    console.log('Saving changes:', changes);
    console.log('CSRF Token:', document.querySelector('[name=csrfmiddlewaretoken]').value);
    
    fetch('/prompts-admin/bulk-reorder/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
        },
        body: JSON.stringify({ changes: changes })
    })
    .then(response => {
        console.log('Response status:', response.status);
        console.log('Response headers:', response.headers);
        
        if (!response.ok) {
            return response.text().then(text => {
                console.error('Response text:', text);
                throw new Error(`HTTP ${response.status}: ${text}`);
            });
        }
        
        return response.json();
    })
    .then(data => {
        console.log('Save response:', data);
        if (data.success) {
            // Clear pending changes
            pendingChanges.clear();
            originalOrder.clear();
            updateSavePanel();
            
            // Show success message
            showMessage('Order saved successfully!', 'success');
        } else {
            throw new Error(data.error || 'Failed to save order');
        }
    })
    .catch(error => {
        console.error('Full error details:', error);
        showMessage('Failed to save order. Check console for details.', 'error');
    })
    .finally(() => {
        saveBtn.innerHTML = originalText;
        saveBtn.disabled = false;
    });
}

function cancelOrderChanges() {
    // Restore original orders
    pendingChanges.forEach((newOrder, slug) => {
        const item = document.querySelector(`[data-slug="${slug}"]`);
        const originalOrderValue = originalOrder.get(slug);
        
        if (item && originalOrderValue !== undefined) {
            item.dataset.order = originalOrderValue;
            const orderDisplay = item.querySelector('.order-display');
            if (orderDisplay) {
                orderDisplay.textContent = originalOrderValue;
            }
        }
    });
    
    // Clear changes
    pendingChanges.clear();
    originalOrder.clear();
    updateSavePanel();
    
    // Redistribute items with hybrid algorithm
    redistributeItems();
    
    showMessage('Changes cancelled', 'info');
}

function showMessage(text, type) {
    // Simple message display
    const message = document.createElement('div');
    message.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        background: ${type === 'success' ? '#28a745' : type === 'error' ? '#dc3545' : '#17a2b8'};
        color: white;
        border-radius: 5px;
        z-index: 10000;
        font-weight: 500;
    `;
    message.textContent = text;
    document.body.appendChild(message);
    
    setTimeout(() => {
        message.remove();
    }, 3000);
}

{% else %}
let orderDisplayVisible = false;

function toggleOrderDisplay() {
    // Simplified version for non-staff users
    const orderDisplays = document.querySelectorAll('.order-display');
    const toggleBtn = document.getElementById('toggle-order-btn');
    orderDisplayVisible = orderDisplays[0]?.style.display !== 'none';
    
    orderDisplays.forEach(display => {
        display.style.display = orderDisplayVisible ? 'none' : 'block';
    });
    
    orderDisplayVisible = !orderDisplayVisible;
    
    if (toggleBtn) {
        const icon = toggleBtn.querySelector('i');
        const text = orderDisplayVisible ? 'Hide Order Numbers' : 'Show Order Numbers';
        toggleBtn.innerHTML = `<i class="fas fa-eye${orderDisplayVisible ? '-slash' : ''}"></i> ${text}`;
    }
}
{% endif %}

function applyOrderDisplayState() {
    // Apply current visibility state to all order displays (including newly loaded ones)
    const orderDisplays = document.querySelectorAll('.order-display');
    orderDisplays.forEach(display => {
        display.style.display = orderDisplayVisible ? 'block' : 'none';
    });
}

// ============================================
// SORT DROPDOWN FUNCTIONALITY (Phase G)
// ============================================
(function() {
    'use strict';

    const dropdown = document.getElementById('sortDropdown');
    const dropdownBtn = document.getElementById('sortDropdownBtn');

    if (!dropdown || !dropdownBtn) return;

    // Toggle dropdown on button click
    dropdownBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        dropdown.classList.toggle('open');
        const isOpen = dropdown.classList.contains('open');
        dropdownBtn.setAttribute('aria-expanded', isOpen);
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', function(e) {
        if (!dropdown.contains(e.target)) {
            dropdown.classList.remove('open');
            dropdownBtn.setAttribute('aria-expanded', 'false');
        }
    });

    // Close dropdown on Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && dropdown.classList.contains('open')) {
            dropdown.classList.remove('open');
            dropdownBtn.setAttribute('aria-expanded', 'false');
            dropdownBtn.focus();
        }
    });
})();
</script>
{% endblock %}