# prompts/admin.py
from django.contrib import admin
from django.contrib.auth.models import User
from django_summernote.admin import SummernoteModelAdmin
from django.urls import reverse, path
from django.utils.html import format_html
from django.utils.safestring import mark_safe
from taggit.models import Tag
from .models import Prompt, Comment, CollaborateRequest, ModerationLog, ContentFlag, ProfanityWord, TagCategory, SubjectCategory, SubjectDescriptor, UserProfile, PromptReport, EmailPreferences, SiteSettings, PromptView, Collection, CollectionItem, SlugRedirect


class SlugRedirectInline(admin.TabularInline):
    model = SlugRedirect
    extra = 0
    readonly_fields = ('old_slug', 'created_at')
    can_delete = True
    verbose_name = 'Slug Redirect (old URL ‚Üí this prompt)'
    verbose_name_plural = 'Slug Redirects (old URLs ‚Üí this prompt)'


@admin.register(Prompt)
class PromptAdmin(SummernoteModelAdmin):
    inlines = [SlugRedirectInline]
    list_display = (
        'title', 'order', 'slug', 'status', 'moderation_badge', 'created_on',
        'author', 'tag_list', 'category_count', 'descriptor_count',
        'number_of_likes', 'ai_generator', 'media_type',
        'deleted_at', 'image_validation', 'reorder_links', 'processing_complete',
    )
    list_display_links = ('title',)
    search_fields = ['title', 'content', 'slug', 'tags__name',
                      'categories__name', 'descriptors__name', 'author__username']
    list_filter = (
        'status', 'moderation_status', 'requires_manual_review',
        'deleted_at', 'created_on', 'ai_generator', 'categories',
    )
    summernote_fields = ('content',)
    filter_horizontal = ('categories', 'descriptors')
    ordering = ['order', '-created_on']
    # Order matters: most important/common actions first
    actions = ['approve_and_publish', 'make_published', 'make_draft', 'reset_order_to_date', 'regenerate_ai_content']
    list_editable = ('order',)
    list_per_page = 50  # Pagination for performance
    date_hierarchy = 'created_on'

    fieldsets = (
        ('Content', {
            'fields': ('id', 'title', 'slug', 'content', 'excerpt'),
            'description': (
                '‚ö†Ô∏è Changing the slug auto-creates a 301 redirect from the old URL. '
                'üìè Title: 10-80 chars for best SEO performance.'
            ),
        }),
        ('AI-Generated Metadata', {
            'fields': ('categories', 'descriptors', 'tags'),
            'description': (
                'ü§ñ Auto-generated by AI during upload. Edit to correct mistakes. '
                'üìä Scoring weights: descriptors 35%, tags 30%, categories 25%.'
            ),
        }),
        ('Media', {
            'fields': ('featured_image', 'featured_video', 'video_duration'),
            'description': (
                'Upload either an image OR a video, not both. '
                '‚ö†Ô∏è Title/slug changes do NOT update stored B2 filenames or alt tags.'
            ),
        }),
        ('Media Preview', {
            'fields': ('image_preview',),
        }),
        ('B2 Media URLs', {
            'classes': ('collapse',),
            'fields': (
                'b2_image_url', 'b2_thumb_url', 'b2_medium_url',
                'b2_large_url', 'b2_webp_url',
                'b2_video_url', 'b2_video_thumb_url',
                'video_width', 'video_height',
            ),
            'description': 'B2/Cloudflare CDN URLs ‚Äî read only, for debugging.',
        }),
        ('Publishing', {
            'fields': ('author', 'status', 'ai_generator', 'order'),
        }),
        ('Moderation', {
            'fields': (
                'moderation_status', 'requires_manual_review', 'needs_seo_review',
                'moderation_completed_at', 'reviewed_by', 'review_notes',
            ),
            'description': 'AI moderation status and manual review',
        }),
        ('Soft Delete', {
            'classes': ('collapse',),
            'fields': ('deleted_at', 'deleted_by', 'deletion_reason', 'original_status'),
            'description': 'üö® Managed by the trash system. Edit with extreme caution.',
        }),
        ('Processing Status', {
            'classes': ('collapse',),
            'fields': ('processing_uuid', 'processing_complete'),
            'description': 'Background processing status for optimistic upload flow',
        }),
        ('Timestamps', {
            'classes': ('collapse',),
            'fields': ('created_on', 'updated_on'),
            'description': 'Automatically managed timestamps',
        }),
    )

    readonly_fields = (
        'id',
        'b2_image_url', 'b2_thumb_url', 'b2_medium_url', 'b2_large_url',
        'b2_webp_url', 'b2_video_url', 'b2_video_thumb_url',
        'video_width', 'video_height',
        'created_on', 'updated_on', 'moderation_completed_at', 'image_preview',
        'processing_uuid', 'processing_complete',
        'deleted_at', 'deleted_by', 'deletion_reason',
    )

    def get_form(self, request, obj=None, **kwargs):
        form = super().get_form(request, obj, **kwargs)
        if 'title' in form.base_fields:
            form.base_fields['title'].help_text = (
                'üìè <strong>10-80 characters recommended.</strong> '
                'Titles appear in Google results (truncated at ~60 chars), '
                'OG/Twitter cards, and browser tabs. '
                '‚ö†Ô∏è Changing the title does NOT update the stored B2 filename or alt tag.'
            )
        if 'slug' in form.base_fields:
            form.base_fields['slug'].help_text = (
                'üîó <strong>URL-safe identifier.</strong> '
                'Lowercase letters, numbers, and hyphens only. Max 200 chars. '
                '‚úÖ Changing the slug auto-creates a 301 redirect from the old URL. '
                'üö´ Reserved: upload, admin, about, collections, browse, search, trash.'
            )
        if 'excerpt' in form.base_fields:
            form.base_fields['excerpt'].help_text = (
                'üìÑ <strong>AI-generated description for SEO.</strong> '
                '150-300 words recommended. '
                'üîç Used in: meta description, OG cards, search result snippets.'
            )
        if 'categories' in form.base_fields:
            form.base_fields['categories'].help_text = (
                'üìÇ <strong>1-5 categories recommended.</strong> '
                'üìä Categories = 25% of related prompts score. '
                'üö® 0 categories = algorithm loses 25% matching signal.'
            )
        if 'descriptors' in form.base_fields:
            form.base_fields['descriptors'].help_text = (
                'üè∑Ô∏è <strong>4-8 descriptors recommended.</strong> '
                'Should span multiple types: gender, ethnicity, mood, color, setting. '
                'üìä Descriptors = 35% of related prompts score ‚Äî the single biggest factor.'
            )
        if 'ai_generator' in form.base_fields:
            form.base_fields['ai_generator'].help_text = (
                'ü§ñ The AI tool used to create this image/video. '
                'üìä 5% of related prompts score. '
                '‚ö†Ô∏è Changing this does NOT update the stored B2 filename.'
            )
        return form

    def formfield_for_manytomany(self, db_field, request, **kwargs):
        if db_field.name == 'tags':
            kwargs['help_text'] = (
                'üè∑Ô∏è <strong>Up to 10 tags.</strong> '
                'üö® ai-art or ai-generated mandatory. '
                'üìä Tags = 30% of related prompts score. '
                'üí° New tags auto-created if typed manually.'
            )
        return super().formfield_for_manytomany(db_field, request, **kwargs)

    def get_queryset(self, request):
        """Optimize queries with select_related and prefetch_related"""
        qs = super().get_queryset(request)
        return qs.select_related(
            'author', 'deleted_by', 'reviewed_by'
        ).prefetch_related('tags', 'likes')

    def tag_list(self, obj):
        return ", ".join(o.name for o in obj.tags.all())
    tag_list.short_description = 'Tags'

    def category_count(self, obj):
        return obj.categories.count()
    category_count.short_description = 'Cats'

    def descriptor_count(self, obj):
        return obj.descriptors.count()
    descriptor_count.short_description = 'Descs'

    def image_preview(self, obj):
        """Display image/video preview in admin"""
        if obj.is_video() and obj.featured_video:
            # For videos, show thumbnail from middle frame
            thumbnail_url = obj.get_thumbnail_url(width=950)
            if thumbnail_url:
                return mark_safe(
                    f'<div style="margin: 10px 0;">'
                    f'<p><strong>Video Preview (middle frame):</strong></p>'
                    f'<img src="{thumbnail_url}" style="max-width: 950px; height: auto; border: 1px solid #ddd; border-radius: 4px;" />'
                    f'<p style="margin-top: 5px; color: #666; font-size: 12px;">Duration: {obj.video_duration or "Unknown"} seconds</p>'
                    f'</div>'
                )
        elif obj.featured_image:
            # For images, show the actual image
            image_url = obj.featured_image.url
            if image_url:
                return mark_safe(
                    f'<div style="margin: 10px 0;">'
                    f'<p><strong>Image Preview:</strong></p>'
                    f'<img src="{image_url}" style="max-width: 950px; height: auto; border: 1px solid #ddd; border-radius: 4px;" />'
                    f'</div>'
                )

        return mark_safe(
            '<p style="color: #999; font-style: italic;">No image or video</p>'
        )
    image_preview.short_description = 'Media Preview'

    def image_validation(self, obj):
        """Check if Cloudinary image/video is valid and accessible"""
        if not obj.featured_image and not obj.featured_video:
            return format_html(
                '<span style="color: #999;">No media</span>'
            )

        try:
            # Try to get the URL - if Cloudinary resource is broken, this will fail
            if obj.featured_image:
                url = obj.featured_image.url
                public_id = obj.featured_image.public_id
                icon = '‚úì'
                color = '#28a745'  # green
                title = f'Valid image: {public_id}'
            elif obj.featured_video:
                url = obj.featured_video.url
                public_id = obj.featured_video.public_id
                icon = '‚úì'
                color = '#28a745'  # green
                title = f'Valid video: {public_id}'

            return format_html(
                '<span style="color: {}; font-weight: bold;" title="{}">{}</span>',
                color, title, icon
            )
        except Exception as e:
            # If we can't access the URL, the Cloudinary resource is broken
            return format_html(
                '<span style="color: #dc3545; font-weight: bold;" title="Error: {}">‚úó BROKEN</span>',
                str(e)
            )
    image_validation.short_description = 'Media Valid?'

    def moderation_badge(self, obj):
        """Display moderation status with color-coded badge"""
        colors = {
            'approved': '#28a745',  # green
            'rejected': '#dc3545',  # red
            'flagged': '#ffc107',   # yellow
            'pending': '#6c757d',   # grey
        }
        icons = {
            'approved': '‚úì',
            'rejected': '‚úó',
            'flagged': '‚ö†',
            'pending': '‚è≥',
        }
        color = colors.get(obj.moderation_status, '#6c757d')
        icon = icons.get(obj.moderation_status, '?')
        review_flag = ' üîç' if obj.requires_manual_review else ''

        return format_html(
            '<span style="background-color: {}; color: white; padding: 3px 8px; '
            'border-radius: 3px; font-weight: bold;">{} {}</span>{}',
            color, icon, obj.get_moderation_status_display(), review_flag
        )
    moderation_badge.short_description = 'Moderation'
    moderation_badge.admin_order_field = 'moderation_status'

    def media_type(self, obj):
        """Display whether the prompt contains an image or video"""
        if obj.is_video():
            return 'üé• Video'
        return 'üñºÔ∏è Image'
    media_type.short_description = 'Type'

    def reorder_links(self, obj):
        """Provide up/down arrows for quick reordering"""
        if obj.pk:
            move_up_url = reverse('admin:prompts_prompt_move_up', args=[obj.pk])
            move_down_url = reverse('admin:prompts_prompt_move_down', args=[obj.pk])
            return format_html(
                '<a href="{}" title="Move Up">‚Üë</a> | <a href="{}" title="Move Down">‚Üì</a>',
                move_up_url, move_down_url
            )
        return "Save first"
    reorder_links.short_description = 'Move'
    reorder_links.allow_tags = True

    def make_published(self, request, queryset):
        """
        Simple publish action - ONLY sets status=1.
        WARNING: Does NOT clear moderation flags.
        """
        # Count flagged prompts that need proper approval
        flagged_count = queryset.filter(
            moderation_status='flagged',
            requires_manual_review=True
        ).count()

        # Warn admin if flagged prompts detected
        if flagged_count > 0:
            from django.contrib import messages
            self.message_user(
                request,
                f'‚ö†Ô∏è WARNING: {flagged_count} prompt(s) still have moderation flags. '
                f'Users will NOT be able to toggle draft/publish on these prompts. '
                f'Use "Approve & Publish" action instead to clear moderation flags.',
                level=messages.WARNING
            )

        # Proceed with simple publish
        updated = queryset.update(status=1)
        self.message_user(
            request,
            f'{updated} prompt{"s" if updated != 1 else ""} published (status only).'
        )
    make_published.short_description = 'Publish (status only - does NOT clear moderation flags)'

    def make_draft(self, request, queryset):
        """Mark prompts as drafts. Does NOT change moderation status."""
        updated = queryset.update(status=0)
        self.message_user(
            request,
            f'{updated} prompt{"s" if updated != 1 else ""} moved to draft.'
        )
    make_draft.short_description = 'Move to Draft'

    def approve_and_publish(self, request, queryset):
        """
        Approve moderation AND publish prompts.
        This clears moderation flags and allows users to toggle draft/publish.
        """
        # Count how many actually need approval
        needs_approval = queryset.filter(
            moderation_status__in=['flagged', 'pending'],
            requires_manual_review=True
        ).count()

        # Update ALL selected prompts
        updated = queryset.update(
            status=1,
            moderation_status='approved',
            requires_manual_review=False
        )

        # Informative success message
        if needs_approval > 0:
            self.message_user(
                request,
                f'‚úì {updated} prompts approved and published. '
                f'{needs_approval} flagged prompt(s) now cleared - users can toggle draft/publish.'
            )
        else:
            self.message_user(
                request,
                f'‚úì {updated} prompts approved and published.'
            )
    approve_and_publish.short_description = 'Approve & Publish (clears moderation flags)'

    def reset_order_to_date(self, request, queryset):
        """Reset order based on creation date (newest first)"""
        prompts = list(queryset.order_by('-created_on'))
        for index, prompt in enumerate(prompts):
            prompt.order = index
            prompt.save(update_fields=['order'])
        
        self.message_user(
            request, 
            f'Reset order for {len(prompts)} prompts based on creation date.'
        )
    reset_order_to_date.short_description = 'Reset order to creation date'

    @staticmethod
    def _get_prompt_image_url(prompt):
        """Get the best available image URL for AI analysis."""
        image_url = prompt.b2_image_url or prompt.b2_video_thumb_url
        if not image_url and prompt.featured_image:
            try:
                image_url = prompt.featured_image.url
            except Exception:
                pass
        return image_url

    @staticmethod
    def _apply_ai_m2m_updates(prompt, ai_result, all_categories, all_descriptors):
        """Apply tags, categories, and descriptors from AI result to prompt."""
        from taggit.models import Tag as TagModel

        tags = ai_result.get('tags', [])
        if tags:
            clean_tags = [str(t).strip()[:100] for t in tags[:10] if t]
            tag_objects = [
                TagModel.objects.get_or_create(name=name)[0]
                for name in clean_tags if name
            ]
            if tag_objects:
                prompt.tags.set(tag_objects)

        categories = ai_result.get('categories', [])
        if categories:
            matched = [
                all_categories[str(c).strip()]
                for c in categories[:5]
                if str(c).strip() in all_categories
            ]
            if matched:
                prompt.categories.set(matched)

        descriptors_dict = ai_result.get('descriptors', {})
        if descriptors_dict and isinstance(descriptors_dict, dict):
            all_names = []
            for vals in descriptors_dict.values():
                if isinstance(vals, list):
                    all_names.extend(str(v).strip() for v in vals if v)
            matched = [all_descriptors[n] for n in all_names if n in all_descriptors]
            if matched:
                prompt.descriptors.set(matched)

    def regenerate_ai_content(self, request, queryset):
        """Re-run AI content generation for selected prompts."""
        from taggit.models import Tag as TagModel
        from prompts.tasks import (
            _call_openai_vision, _sanitize_content,
            _generate_unique_slug_with_retry,
        )
        from prompts.models import SubjectCategory, SubjectDescriptor
        from django.db import transaction

        count = queryset.count()
        if count > 10:
            self.message_user(
                request,
                f'üö´ {count} prompts selected ‚Äî max 10 for inline regeneration. '
                f'üí° Use: python manage.py backfill_ai_content --limit {count}',
                level='warning'
            )
            return

        available_tags = list(TagModel.objects.values_list('name', flat=True)[:200])
        all_categories = {c.name: c for c in SubjectCategory.objects.all()}
        all_descriptors = {d.name: d for d in SubjectDescriptor.objects.all()}

        success = 0
        errors = []
        for prompt in queryset:
            image_url = self._get_prompt_image_url(prompt)
            if not image_url:
                errors.append(f'{prompt.title[:30]}: No image URL')
                continue
            try:
                ai_result = _call_openai_vision(
                    image_url=image_url,
                    prompt_text=prompt.content[:500] if prompt.content else '',
                    ai_generator=(
                        prompt.get_ai_generator_display()
                        if hasattr(prompt, 'get_ai_generator_display')
                        else 'AI'
                    ),
                    available_tags=available_tags,
                )
                if ai_result.get('error'):
                    errors.append(f'{prompt.title[:30]}: {ai_result["error"][:50]}')
                    continue

                title = _sanitize_content(
                    ai_result.get('title') or f'AI Artwork #{prompt.pk}',
                    max_length=200,
                )
                description = _sanitize_content(
                    ai_result.get('description', ''), max_length=2000,
                )

                with transaction.atomic():
                    slug = _generate_unique_slug_with_retry(prompt, title)
                    old_slug = prompt.slug
                    prompt.title = title
                    prompt.excerpt = description
                    prompt.slug = slug
                    prompt.save(update_fields=['title', 'excerpt', 'slug'])

                    if old_slug != slug:
                        SlugRedirect.objects.filter(old_slug=slug).delete()
                        SlugRedirect.objects.update_or_create(
                            old_slug=old_slug,
                            defaults={'prompt': prompt}
                        )

                    self._apply_ai_m2m_updates(
                        prompt, ai_result, all_categories, all_descriptors,
                    )
                success += 1
            except Exception as e:
                errors.append(f'{prompt.title[:30]}: {str(e)[:50]}')

        if errors:
            self.message_user(
                request,
                f'‚ö†Ô∏è Regenerated {success}/{count}. Errors: {"; ".join(errors)}',
                level='warning'
            )
        else:
            self.message_user(
                request,
                f'‚úÖ Regenerated AI content for {success} prompt(s).'
            )
    regenerate_ai_content.short_description = (
        'üîÑ Regenerate AI content (üö® overwrites ALL metadata)'
    )

    def get_urls(self):
        """Add custom URLs for move up/down actions"""
        from django.urls import path
        urls = super().get_urls()
        custom_urls = [
            path(
                '<int:pk>/move-up/',
                self.admin_site.admin_view(self.move_up_view),
                name='prompts_prompt_move_up',
            ),
            path(
                '<int:pk>/move-down/',
                self.admin_site.admin_view(self.move_down_view),
                name='prompts_prompt_move_down',
            ),
        ]
        return custom_urls + urls

    def move_up_view(self, request, pk):
        """Move prompt up in order (decrease order number)"""
        from django.shortcuts import get_object_or_404, redirect
        from django.contrib import messages
        from django.core.cache import cache
        
        prompt = get_object_or_404(Prompt, pk=pk)
        
        # Find the prompt with the next lower order number
        previous_prompt = Prompt.objects.filter(
            order__lt=prompt.order
        ).order_by('-order').first()
        
        if previous_prompt:
            # Swap the order values
            prompt.order, previous_prompt.order = previous_prompt.order, prompt.order
            prompt.save(update_fields=['order'])
            previous_prompt.save(update_fields=['order'])
            
            # Clear all relevant caches
            self.clear_prompt_caches()
            
            messages.success(request, f'Moved "{prompt.title}" up.')
        else:
            messages.warning(request, f'"{prompt.title}" is already at the top.')
        
        return redirect('admin:prompts_prompt_changelist')

    def move_down_view(self, request, pk):
        """Move prompt down in order (increase order number)"""
        from django.shortcuts import get_object_or_404, redirect
        from django.contrib import messages
        from django.core.cache import cache
        
        prompt = get_object_or_404(Prompt, pk=pk)
        
        # Find the prompt with the next higher order number
        next_prompt = Prompt.objects.filter(
            order__gt=prompt.order
        ).order_by('order').first()
        
        if next_prompt:
            # Swap the order values
            prompt.order, next_prompt.order = next_prompt.order, prompt.order
            prompt.save(update_fields=['order'])
            next_prompt.save(update_fields=['order'])
            
            # Clear all relevant caches
            self.clear_prompt_caches()
            
            messages.success(request, f'Moved "{prompt.title}" down.')
        else:
            messages.warning(request, f'"{prompt.title}" is already at the bottom.')
        
        return redirect('admin:prompts_prompt_changelist')

    def clear_prompt_caches(self):
        """Clear all prompt-related caches"""
        from django.core.cache import cache
        
        # Clear list caches for multiple pages and tags
        for page in range(1, 10):  # Clear more pages
            cache.delete(f"prompt_list_None_None_{page}")
            # Clear tag-filtered caches too
            for tag in ['art', 'portrait', 'landscape', 'photography']:  # Add your common tags
                cache.delete(f"prompt_list_{tag}_None_{page}")
        
        # Clear individual prompt detail caches
        prompts = Prompt.objects.all()[:50]  # Clear recent prompts
        for prompt in prompts:
            cache.delete(f"prompt_detail_{prompt.slug}_anonymous")
            # Clear user-specific caches (this is imperfect, but helps)
            for user_id in range(1, 20):  # Adjust range based on your user count
                cache.delete(f"prompt_detail_{prompt.slug}_{user_id}")

    # Reserved slugs that conflict with system URLs
    RESERVED_SLUGS = {
        'upload', 'admin', 'about', 'contact', 'login', 'logout', 'signup',
        'register', 'settings', 'profile', 'users', 'api', 'search',
        'collections', 'leaderboard', 'categories', 'browse', 'tags',
        'processing', 'sitemap.xml', 'robots.txt', 'favicon.ico',
        'static', 'media', 'accounts', 'trash',
    }

    def save_model(self, request, obj, form, change):
        """Slug redirect + validation + cache clearing on save.

        Note: Early return on slug validation failure prevents save of ALL
        fields (Django admin limitation). Move to form clean() if this
        becomes a UX issue.
        """
        import re
        from django.db import transaction

        if change and 'slug' in form.changed_data:
            old_prompt = Prompt.all_objects.get(pk=obj.pk)
            old_slug = old_prompt.slug
            new_slug = obj.slug

            if old_slug != new_slug:
                # Validate format
                if not re.match(r'^[a-z0-9]([a-z0-9-]*[a-z0-9])?$', new_slug):
                    self.message_user(
                        request,
                        f'üö´ Slug "{new_slug}" contains invalid characters. '
                        f'Use only lowercase letters, numbers, and hyphens.',
                        level='error'
                    )
                    return

                # Check reserved
                if new_slug in self.RESERVED_SLUGS:
                    self.message_user(
                        request,
                        f'üö´ Slug "{new_slug}" is reserved (system URL). '
                        f'Choose a different slug.',
                        level='error'
                    )
                    return

                # Check uniqueness against other prompts
                if Prompt.all_objects.filter(slug=new_slug).exclude(pk=obj.pk).exists():
                    self.message_user(
                        request,
                        f'üö´ Slug "{new_slug}" is already used by another prompt.',
                        level='error'
                    )
                    return

                with transaction.atomic():
                    # Prevent circular redirects
                    SlugRedirect.objects.filter(old_slug=new_slug).delete()
                    # Create or update redirect for old slug
                    SlugRedirect.objects.update_or_create(
                        old_slug=old_slug,
                        defaults={'prompt': obj}
                    )

                self.message_user(
                    request,
                    f'‚úÖ Slug changed: "{old_slug}" ‚Üí "{new_slug}". '
                    f'üîó 301 redirect created automatically.',
                    level='success'
                )

        # Title length warnings (non-blocking)
        if obj.title:
            title_len = len(obj.title)
            if title_len > 80:
                self.message_user(
                    request,
                    f'‚ö†Ô∏è Title is {title_len} chars (recommended: 10-80 for SEO).',
                    level='warning'
                )
            elif title_len < 10:
                self.message_user(
                    request,
                    f'‚ö†Ô∏è Title is only {title_len} chars (recommended: 10-80 for SEO).',
                    level='warning'
                )

        super().save_model(request, obj, form, change)

        if change and 'order' in form.changed_data:
            self.clear_prompt_caches()

    def save_related(self, request, form, formsets, change):
        """M2M validation warnings after save."""
        super().save_related(request, form, formsets, change)
        obj = form.instance

        cat_count = obj.categories.count()
        if cat_count == 0:
            self.message_user(
                request,
                '‚ö†Ô∏è No categories assigned. '
                'üìä Related prompts algorithm loses 25% signal.',
                level='warning'
            )
        elif cat_count > 5:
            self.message_user(
                request,
                f'‚ö†Ô∏è {cat_count} categories assigned (recommended max: 5).',
                level='warning'
            )

        desc_count = obj.descriptors.count()
        if desc_count == 0:
            self.message_user(
                request,
                'üö® No descriptors assigned. '
                'üìä Descriptors = 35% of related prompts score.',
                level='warning'
            )
        elif desc_count > 10:
            self.message_user(
                request,
                f'‚ö†Ô∏è {desc_count} descriptors assigned (recommended: 4-8).',
                level='warning'
            )

        tag_count = obj.tags.count()
        if tag_count == 0:
            self.message_user(
                request,
                'üö® No tags assigned. '
                'üìä Tags = 30% of related prompts score.',
                level='warning'
            )
        elif tag_count > 10:
            self.message_user(
                request,
                f'‚ö†Ô∏è {tag_count} tags assigned (max recommended: 10).',
                level='warning'
            )

        # Check mandatory tags
        tag_names = set(obj.tags.names())
        mandatory_tags = {'ai-art', 'ai-generated'}
        if tag_names and not (tag_names & mandatory_tags):
            self.message_user(
                request,
                'üö® Missing mandatory tags: ai-art or ai-generated.',
                level='warning'
            )


@admin.register(Comment)
class CommentAdmin(admin.ModelAdmin):
    list_display = ['prompt', 'author', 'body', 'created_on', 'approved']
    list_filter = ['approved', 'created_on']
    search_fields = ['author__username', 'body']
    actions = ['approve_comments']

    def approve_comments(self, request, queryset):
        queryset.update(approved=True)
    approve_comments.short_description = "Approve selected comments"


@admin.register(CollaborateRequest)
class CollaborateRequestAdmin(admin.ModelAdmin):
    list_display = ['name', 'email', 'message', 'read', 'created_on']
    list_filter = ['read', 'created_on']
    search_fields = ['name', 'email']


class ContentFlagInline(admin.TabularInline):
    """Inline display of content flags within ModerationLog"""
    model = ContentFlag
    extra = 0
    readonly_fields = ('category', 'confidence', 'severity', 'details', 'created_at')
    can_delete = False

    def has_add_permission(self, request, obj=None):
        return False


@admin.register(ModerationLog)
class ModerationLogAdmin(admin.ModelAdmin):
    """Admin interface for viewing moderation logs"""
    list_display = [
        'prompt_link', 'service', 'status_badge', 'confidence_score',
        'flag_count', 'moderated_at'
    ]
    list_filter = ['service', 'status', 'moderated_at']
    search_fields = ['prompt__title', 'notes']
    readonly_fields = [
        'prompt', 'service', 'status', 'confidence_score',
        'flagged_categories', 'raw_response', 'moderated_at', 'notes'
    ]
    inlines = [ContentFlagInline]
    date_hierarchy = 'moderated_at'

    fieldsets = (
        ('Prompt Information', {
            'fields': ('prompt', 'service', 'moderated_at')
        }),
        ('Moderation Results', {
            'fields': ('status', 'confidence_score', 'flagged_categories')
        }),
        ('Details', {
            'fields': ('notes', 'raw_response'),
            'classes': ('collapse',),
        }),
    )

    def prompt_link(self, obj):
        """Link to the prompt being moderated"""
        url = reverse('admin:prompts_prompt_change', args=[obj.prompt.pk])
        return format_html('<a href="{}">{}</a>', url, obj.prompt.title)
    prompt_link.short_description = 'Prompt'

    def status_badge(self, obj):
        """Display status with color-coded badge"""
        colors = {
            'approved': '#28a745',
            'rejected': '#dc3545',
            'flagged': '#ffc107',
            'pending': '#6c757d',
        }
        color = colors.get(obj.status, '#6c757d')
        return format_html(
            '<span style="background-color: {}; color: white; padding: 3px 8px; '
            'border-radius: 3px;">{}</span>',
            color, obj.get_status_display()
        )
    status_badge.short_description = 'Status'
    status_badge.admin_order_field = 'status'

    def flag_count(self, obj):
        """Number of content flags detected"""
        count = obj.flags.count()
        if count > 0:
            return format_html('<strong style="color: red;">{}</strong>', count)
        return count
    flag_count.short_description = 'Flags'

    def has_add_permission(self, request):
        """Prevent manual creation of moderation logs"""
        return False

    def has_delete_permission(self, request, obj=None):
        """Allow deletion for cleanup"""
        return True


@admin.register(ContentFlag)
class ContentFlagAdmin(admin.ModelAdmin):
    """Admin interface for viewing content flags"""
    list_display = [
        'moderation_log_link', 'category', 'confidence_display',
        'severity_badge', 'created_at'
    ]
    list_filter = ['severity', 'category', 'created_at']
    search_fields = ['category', 'moderation_log__prompt__title']
    readonly_fields = [
        'moderation_log', 'category', 'confidence', 'severity',
        'details', 'created_at'
    ]
    date_hierarchy = 'created_at'

    fieldsets = (
        ('Flag Information', {
            'fields': ('moderation_log', 'category', 'severity')
        }),
        ('Detection Details', {
            'fields': ('confidence', 'details', 'created_at')
        }),
    )

    def moderation_log_link(self, obj):
        """Link to parent moderation log"""
        url = reverse('admin:prompts_moderationlog_change', args=[obj.moderation_log.pk])
        return format_html(
            '<a href="{}">{} - {}</a>',
            url, obj.moderation_log.prompt.title, obj.moderation_log.get_service_display()
        )
    moderation_log_link.short_description = 'Moderation Log'

    def confidence_display(self, obj):
        """Display confidence as percentage"""
        return f"{obj.confidence * 100:.1f}%"
    confidence_display.short_description = 'Confidence'
    confidence_display.admin_order_field = 'confidence'

    def severity_badge(self, obj):
        """Display severity with color"""
        colors = {
            'critical': '#dc3545',
            'high': '#fd7e14',
            'medium': '#ffc107',
            'low': '#28a745',
        }
        color = colors.get(obj.severity, '#6c757d')
        return format_html(
            '<span style="background-color: {}; color: white; padding: 3px 8px; '
            'border-radius: 3px;">{}</span>',
            color, obj.get_severity_display()
        )
    severity_badge.short_description = 'Severity'
    severity_badge.admin_order_field = 'severity'

    def has_add_permission(self, request):
        """Prevent manual creation of flags"""
        return False

    def has_delete_permission(self, request, obj=None):
        """Allow deletion for cleanup"""
        return True


@admin.register(ProfanityWord)
class ProfanityWordAdmin(admin.ModelAdmin):
    """Admin interface for managing profanity word list"""
    list_display = [
        "word_display", "severity_badge", "is_active_display",
        "created_at", "updated_at"
    ]
    list_filter = ["severity", "is_active", "created_at"]
    search_fields = ["word", "notes"]
    list_editable = []
    actions = [
        "activate_words", "deactivate_words",
        "set_severity_critical", "set_severity_high"
    ]

    change_list_template = "admin/profanity_word_changelist.html"

    fieldsets = (
        ("Word Information", {
            "fields": ("word", "severity", "is_active")
        }),
        ("Notes", {
            "fields": ("notes",),
            "classes": ("collapse",),
        }),
        ("Timestamps", {
            "fields": ("created_at", "updated_at"),
            "classes": ("collapse",),
        }),
    )

    readonly_fields = ("created_at", "updated_at")

    def word_display(self, obj):
        """Display uncensored word for admin management"""
        return obj.word
    word_display.short_description = "Word"
    word_display.admin_order_field = "word"

    def severity_badge(self, obj):
        """Display severity with color"""
        colors = {
            "critical": "#dc3545",
            "high": "#fd7e14",
            "medium": "#ffc107",
            "low": "#28a745",
        }
        color = colors.get(obj.severity, "#6c757d")
        return format_html(
            "<span style=\"background-color: {}; color: white; padding: 3px 8px; "
            "border-radius: 3px;\">{}</span>",
            color, obj.get_severity_display()
        )
    severity_badge.short_description = "Severity"
    severity_badge.admin_order_field = "severity"

    def is_active_display(self, obj):
        """Display active status with icon"""
        if obj.is_active:
            return format_html(
                "<span style=\"color: green; font-size: 16px;\">‚úì Active</span>"
            )
        return format_html(
            "<span style=\"color: red; font-size: 16px;\">‚úó Inactive</span>"
        )
    is_active_display.short_description = "Status"
    is_active_display.admin_order_field = "is_active"

    # Admin actions
    def activate_words(self, request, queryset):
        """Activate selected words"""
        updated = queryset.update(is_active=True)
        self.message_user(request, f"{updated} words activated.")
    activate_words.short_description = "Activate selected words"

    def deactivate_words(self, request, queryset):
        """Deactivate selected words"""
        updated = queryset.update(is_active=False)
        self.message_user(request, f"{updated} words deactivated.")
    deactivate_words.short_description = "Deactivate selected words"

    def set_severity_critical(self, request, queryset):
        """Set severity to critical"""
        updated = queryset.update(severity="critical")
        self.message_user(request, f"{updated} words set to critical severity.")
    set_severity_critical.short_description = "Set severity to Critical"

    def set_severity_high(self, request, queryset):
        """Set severity to high"""
        updated = queryset.update(severity="high")
        self.message_user(request, f"{updated} words set to high severity.")
    set_severity_high.short_description = "Set severity to High"

    def get_urls(self):
        """Add custom URL for bulk import"""
        urls = super().get_urls()
        custom_urls = [
            path('bulk-import/', self.admin_site.admin_view(self.bulk_import_view), name='prompts_profanityword_bulk_import'),
        ]
        return custom_urls + urls

    def bulk_import_view(self, request):
        """Bulk import words from comma-separated input"""
        from django import forms
        from django.shortcuts import render, redirect
        from django.contrib import messages
        import re
        import logging

        logger = logging.getLogger(__name__)

        class BulkImportForm(forms.Form):
            words = forms.CharField(
                widget=forms.Textarea(attrs={
                    'rows': 10,
                    'cols': 60,
                    'placeholder': 'Enter comma-separated words, e.g.: fuck, shit, ass, bitch'
                }),
                label="Words to Import",
                help_text="Enter words separated by commas. Duplicates will be skipped."
            )
            severity = forms.ChoiceField(
                choices=ProfanityWord.SEVERITY_CHOICES,
                initial="high",
                label="Severity Level",
                help_text="Severity level for all imported words"
            )
            is_active = forms.BooleanField(
                initial=True,
                required=False,
                label="Active",
                help_text="Mark all imported words as active"
            )

        if request.method == 'POST':
            logger.info(f"POST request received: {request.POST}")
            form = BulkImportForm(request.POST)
            logger.info(f"Form valid: {form.is_valid()}")
            if form.errors:
                logger.error(f"Form errors: {form.errors}")

            if form.is_valid():
                try:
                    words_input = form.cleaned_data['words']
                    severity = form.cleaned_data['severity']
                    is_active = form.cleaned_data['is_active']

                    logger.info(f"Input: {words_input}, Severity: {severity}, Active: {is_active}")

                    # Split by comma, newline, or semicolon and clean up
                    # This handles various input formats users might paste
                    raw_words = re.split(r'[,;\n\r]+', words_input)
                    words = [w.strip().lower() for w in raw_words if w.strip()]

                    logger.info(f"Parsed words: {words}")

                    created_count = 0
                    skipped_count = 0
                    existing_words = []
                    created_words = []

                    for word in words:
                        # Skip empty words
                        if not word:
                            continue

                        # Check if word already exists
                        if ProfanityWord.objects.filter(word=word).exists():
                            skipped_count += 1
                            existing_words.append(word)
                            logger.info(f"Skipped duplicate: {word}")
                        else:
                            obj = ProfanityWord.objects.create(
                                word=word,
                                severity=severity,
                                is_active=is_active
                            )
                            created_count += 1
                            created_words.append(word)
                            logger.info(f"Created: {word} (ID: {obj.id})")

                    # Show detailed success message
                    if created_count > 0:
                        word_preview = ', '.join(created_words[:5])
                        if len(created_words) > 5:
                            word_preview += f' (and {len(created_words) - 5} more)'
                        self.message_user(
                            request,
                            f"Successfully imported {created_count} words: {word_preview}",
                            messages.SUCCESS
                        )

                    # Show warning for skipped words
                    if skipped_count > 0:
                        self.message_user(
                            request,
                            f"Skipped {skipped_count} duplicate words: {', '.join(existing_words[:10])}{'...' if len(existing_words) > 10 else ''}",
                            messages.WARNING
                        )

                    # Show info if no words were processed
                    if created_count == 0 and skipped_count == 0:
                        self.message_user(
                            request,
                            "No words found in input. Please enter comma-separated words.",
                            messages.WARNING
                        )

                    logger.info(f"Import complete: {created_count} created, {skipped_count} skipped")
                    # Redirect back to changelist after processing
                    return redirect('admin:prompts_profanityword_changelist')

                except Exception as e:
                    logger.exception(f"Error during bulk import: {e}")
                    self.message_user(
                        request,
                        f"Error during import: {str(e)}",
                        messages.ERROR
                    )
                    return redirect('admin:prompts_profanityword_changelist')

        else:
            form = BulkImportForm()

        context = {
            **self.admin_site.each_context(request),
            'form': form,
            'title': 'Bulk Import Profanity Words',
            'opts': self.model._meta,
            'has_view_permission': self.has_view_permission(request),
            'has_change_permission': self.has_change_permission(request),
            'has_add_permission': self.has_add_permission(request),
            'has_delete_permission': self.has_delete_permission(request),
            'is_nav_sidebar_enabled': True,
            'available_apps': self.admin_site.get_app_list(request),
        }
        return render(request, 'admin/profanity_bulk_import.html', context)


# Unregister default Tag admin if it exists
try:
    admin.site.unregister(Tag)
except admin.sites.NotRegistered:
    pass


@admin.register(TagCategory)
class TagCategoryAdmin(admin.ModelAdmin):
    """Admin interface for managing tags organized by categories"""
    list_display = ['tag_name', 'category_display', 'prompt_count']
    list_filter = ['category']
    search_fields = ['tag__name', 'tag__slug']
    ordering = ['category', 'tag__name']
    readonly_fields = ['tag', 'category']

    def tag_name(self, obj):
        """Display the tag name"""
        return obj.tag.name
    tag_name.short_description = 'Tag'
    tag_name.admin_order_field = 'tag__name'

    def category_display(self, obj):
        """Display the human-readable category name"""
        return obj.get_category_display()
    category_display.short_description = 'Category'
    category_display.admin_order_field = 'category'

    def prompt_count(self, obj):
        """Display how many prompts use this tag"""
        return obj.tag.taggit_taggeditem_items.count()
    prompt_count.short_description = 'Used in Prompts'

    def has_add_permission(self, request):
        """Prevent manual addition - tags should be added via data migrations"""
        return False

    def has_delete_permission(self, request, obj=None):
        """Allow deletion for cleanup"""
        return True


@admin.register(SubjectCategory)
class SubjectCategoryAdmin(admin.ModelAdmin):
    """Admin interface for managing prompt subject categories (25 predefined)."""
    list_display = ['name', 'slug', 'display_order', 'prompt_count']
    list_display_links = ['name']
    search_fields = ['name', 'slug', 'description']
    ordering = ['display_order', 'name']
    readonly_fields = ['slug']  # Prevent slug changes after creation
    prepopulated_fields = {}  # Disabled since categories are pre-seeded

    def prompt_count(self, obj):
        """Display how many prompts have this category."""
        return obj.prompts.count()
    prompt_count.short_description = 'Prompts'

    def has_add_permission(self, request):
        """Categories are pre-seeded via migrations; prevent manual addition."""
        return False

    def has_delete_permission(self, request, obj=None):
        """Prevent deletion of predefined categories."""
        return False


@admin.register(SubjectDescriptor)
class SubjectDescriptorAdmin(admin.ModelAdmin):
    """Admin interface for managing subject descriptors (Tier 2 taxonomy)."""
    list_display = ['name', 'descriptor_type', 'slug', 'prompt_count']
    list_filter = ['descriptor_type']
    search_fields = ['name', 'slug']
    prepopulated_fields = {'slug': ('name',)}
    readonly_fields = ['prompt_count']

    def get_queryset(self, request):
        from django.db.models import Count
        return super().get_queryset(request).annotate(
            _prompt_count=Count('prompts')
        )

    def prompt_count(self, obj):
        return getattr(obj, '_prompt_count', obj.prompts.count())
    prompt_count.short_description = 'Prompts'
    prompt_count.admin_order_field = '_prompt_count'


@admin.register(UserProfile)
class UserProfileAdmin(admin.ModelAdmin):
    """
    Admin interface for UserProfile model.
    
    Features:
    - List view with bio preview, avatar status
    - Search by username, email, bio
    - Filter by creation date
    - Organized fieldsets (User, Profile Info, Social Media, Timestamps)
    - Read-only timestamps
    """
    list_display = ["user", "bio_preview", "has_avatar", "created_at"]
    list_filter = ["created_at", "updated_at"]
    search_fields = ["user__username", "user__email", "bio"]
    readonly_fields = ["created_at", "updated_at"]
    list_per_page = 50
    
    fieldsets = (
        ("User", {
            "fields": ("user",)
        }),
        ("Profile Information", {
            "fields": ("bio", "avatar")
        }),
        ("Social Media", {
            "fields": ("twitter_url", "instagram_url", "website_url")
        }),
        ("Timestamps", {
            "fields": ("created_at", "updated_at"),
            "classes": ("collapse",)
        }),
    )
    
    def bio_preview(self, obj):
        """Show first 50 chars of bio"""
        if obj.bio:
            return obj.bio[:50] + "..." if len(obj.bio) > 50 else obj.bio
        return "(No bio)"
    bio_preview.short_description = "Bio"
    
    def has_avatar(self, obj):
        """Show if user has uploaded avatar"""
        return bool(obj.avatar)
    has_avatar.boolean = True
    has_avatar.short_description = "Avatar"


# Import AvatarChangeLog model for admin registration
from .models import AvatarChangeLog


@admin.register(AvatarChangeLog)
class AvatarChangeLogAdmin(admin.ModelAdmin):
    """
    Admin interface for Avatar Change Logs.

    Read-only audit trail for avatar changes. Supports debugging
    Cloudinary sync issues and tracking avatar upload patterns.

    Features:
    - List view with user, action, timestamp
    - Filtering by action type, date
    - Search by username, public IDs
    - All fields read-only (audit log, no editing)
    """
    list_display = [
        "id", "user_link", "action_badge", "old_public_id_short",
        "new_public_id_short", "created_at"
    ]
    list_filter = ["action", "created_at"]
    search_fields = [
        "user__username", "old_public_id", "new_public_id", "notes"
    ]
    readonly_fields = [
        "user", "action", "old_public_id", "new_public_id",
        "old_url", "new_url", "created_at", "notes"
    ]
    list_per_page = 50
    date_hierarchy = "created_at"
    ordering = ["-created_at"]

    fieldsets = (
        ("User Information", {
            "fields": ("user", "action", "created_at")
        }),
        ("Avatar Details", {
            "fields": (
                "old_public_id", "new_public_id",
                "old_url", "new_url"
            )
        }),
        ("Notes", {
            "fields": ("notes",),
            "classes": ("collapse",)
        }),
    )

    def has_add_permission(self, request):
        """Prevent manual creation - logs created by signals only"""
        return False

    def has_change_permission(self, request, obj=None):
        """Prevent editing - audit logs are immutable"""
        return False

    def has_delete_permission(self, request, obj=None):
        """Allow deletion for cleanup of old logs"""
        return True

    def user_link(self, obj):
        """Link to user's profile in admin"""
        url = reverse("admin:auth_user_change", args=[obj.user.pk])
        return format_html('<a href="{}">{}</a>', url, obj.user.username)
    user_link.short_description = "User"
    user_link.admin_order_field = "user__username"

    def action_badge(self, obj):
        """Display action with color-coded badge"""
        colors = {
            "upload": "#28a745",       # Green - new upload
            "replace": "#007bff",      # Blue - replacement
            "delete": "#6c757d",       # Gray - deletion
            "delete_failed": "#dc3545", # Red - failed deletion
        }
        color = colors.get(obj.action, "#6c757d")
        return format_html(
            '<span style="background-color: {}; color: white; padding: 3px 8px; '
            'border-radius: 3px; font-size: 11px;">{}</span>',
            color, obj.get_action_display()
        )
    action_badge.short_description = "Action"
    action_badge.admin_order_field = "action"

    def old_public_id_short(self, obj):
        """Truncate old public ID for display"""
        if obj.old_public_id:
            if len(obj.old_public_id) > 30:
                return f"...{obj.old_public_id[-27:]}"
            return obj.old_public_id
        return "-"
    old_public_id_short.short_description = "Old ID"

    def new_public_id_short(self, obj):
        """Truncate new public ID for display"""
        if obj.new_public_id:
            if len(obj.new_public_id) > 30:
                return f"...{obj.new_public_id[-27:]}"
            return obj.new_public_id
        return "-"
    new_public_id_short.short_description = "New ID"


@admin.register(PromptReport)
class PromptReportAdmin(admin.ModelAdmin):
    """
    Admin interface for PromptReport model.

    Features:
    - List view with prompt title, reporter, reason, status
    - Bulk actions for marking as reviewed/dismissed
    - Filtering by status, reason, date
    - Search by prompt title, reporter, comment
    - Optimized queries with select_related
    - Color-coded status badges
    """
    list_display = [
        "id", "view_report_link", "prompt_title_link", "reported_by",
        "reason_display", "comment_preview", "status_badge", "created_at"
    ]
    list_filter = ["status", "reason", "created_at"]
    search_fields = [
        "prompt__title", "reported_by__username", "comment", "admin_notes"
    ]
    readonly_fields = ["prompt", "reported_by", "created_at", "reviewed_at"]
    list_per_page = 50
    date_hierarchy = "created_at"
    actions = ["mark_as_reviewed", "mark_as_dismissed", "mark_as_action_taken"]

    fieldsets = (
        ("Report Information", {
            "fields": ("prompt", "reported_by", "reason", "comment")
        }),
        ("Status", {
            "fields": ("status", "reviewed_by", "admin_notes")
        }),
        ("Timestamps", {
            "fields": ("created_at", "reviewed_at"),
            "classes": ("collapse",)
        }),
    )

    def get_queryset(self, request):
        """Optimize queries with select_related"""
        qs = super().get_queryset(request)
        return qs.select_related("prompt", "reported_by", "reviewed_by")

    def view_report_link(self, obj):
        """Create a clickable 'View Report' button"""
        url = reverse("admin:prompts_promptreport_change", args=[obj.id])
        return format_html(
            '<a class="button" href="{}" style="padding: 5px 10px; background: #417690; '
            'color: white; text-decoration: none; border-radius: 4px; display: inline-block;">'
            'View Report</a>',
            url
        )
    view_report_link.short_description = "Actions"
    view_report_link.allow_tags = True

    def comment_preview(self, obj):
        """Show first 50 characters of the comment"""
        if obj.comment and obj.comment.strip():
            preview = obj.comment[:50]
            if len(obj.comment) > 50:
                preview += "..."
            return preview
        return "(no comment)"
    comment_preview.short_description = "Comment"

    def prompt_title_link(self, obj):
        """Display prompt title as clickable link to prompt admin page"""
        url = reverse("admin:prompts_prompt_change", args=[obj.prompt.pk])
        return format_html(
            '<a href="{}" target="_blank">{}</a>',
            url, obj.prompt.title
        )
    prompt_title_link.short_description = "Prompt"
    prompt_title_link.admin_order_field = "prompt__title"

    def reason_display(self, obj):
        """Display reason with icon"""
        icons = {
            "inappropriate": "üö´",
            "spam": "üìß",
            "copyright": "¬©Ô∏è",
            "harassment": "‚ö†Ô∏è",
            "other": "‚ùì",
        }
        icon = icons.get(obj.reason, "")
        return f"{icon} {obj.get_reason_display()}"
    reason_display.short_description = "Reason"
    reason_display.admin_order_field = "reason"

    def status_badge(self, obj):
        """Display status with color-coded badge"""
        colors = {
            "pending": "#ffc107",      # yellow
            "reviewed": "#28a745",     # green
            "dismissed": "#6c757d",    # grey
            "action_taken": "#007bff", # blue
        }
        color = colors.get(obj.status, "#6c757d")
        return format_html(
            '<span style="background-color: {}; color: white; padding: 3px 8px; '
            'border-radius: 3px; font-weight: bold;">{}</span>',
            color, obj.get_status_display()
        )
    status_badge.short_description = "Status"
    status_badge.admin_order_field = "status"

    # Bulk Actions
    def mark_as_reviewed(self, request, queryset):
        """Mark selected reports as reviewed"""
        updated = 0
        for report in queryset:
            if report.status == "pending":
                report.mark_reviewed(request.user, notes="Bulk action: Marked as reviewed")
                updated += 1

        self.message_user(
            request,
            f"{updated} reports marked as reviewed."
        )
    mark_as_reviewed.short_description = "Mark as Reviewed"

    def mark_as_dismissed(self, request, queryset):
        """Dismiss selected reports"""
        updated = 0
        for report in queryset:
            if report.status == "pending":
                report.mark_dismissed(request.user, notes="Bulk action: Dismissed")
                updated += 1

        self.message_user(
            request,
            f"{updated} reports dismissed."
        )
    mark_as_dismissed.short_description = "Dismiss Reports"

    def mark_as_action_taken(self, request, queryset):
        """Mark selected reports as action taken"""
        from django.utils import timezone
        updated = queryset.filter(status="pending").update(
            status="action_taken",
            reviewed_by=request.user,
            reviewed_at=timezone.now()
        )

        self.message_user(
            request,
            f"{updated} reports marked as action taken."
        )
    mark_as_action_taken.short_description = "Mark as Action Taken"

    def has_add_permission(self, request):
        """Prevent manual creation - reports come from users"""
        return False


@admin.register(EmailPreferences)
class EmailPreferencesAdmin(admin.ModelAdmin):
    """
    Admin interface for EmailPreferences model.

    Features:
    - List view with all notification toggles
    - Filter by notification preferences
    - Search by username/email
    - Organized fieldsets by notification type
    - Read-only token and timestamps
    - Deletion warnings for bulk operations (protects user data)

    CRITICAL: User email preferences are valuable data.
    Deletion should be rare and carefully considered.
    """
    list_display = [
        'user',
        'notify_comments',
        'notify_replies',
        'notify_follows',
        'notify_likes',
        'notify_mentions',
        'notify_weekly_digest',
        'notify_updates',
        'notify_marketing',
        'updated_at'
    ]
    list_filter = [
        'notify_comments',
        'notify_replies',
        'notify_follows',
        'notify_likes',
        'notify_mentions',
        'notify_weekly_digest',
        'notify_updates',
        'notify_marketing',
        'updated_at'
    ]
    search_fields = ['user__username', 'user__email']
    readonly_fields = ['unsubscribe_token', 'updated_at']
    list_per_page = 50

    fieldsets = (
        ('User', {
            'fields': ('user',)
        }),
        ('Activity Notifications', {
            'fields': ('notify_comments', 'notify_replies'),
            'description': 'Notifications about activity on your content'
        }),
        ('Social Notifications', {
            'fields': ('notify_follows', 'notify_likes', 'notify_mentions'),
            'description': 'Notifications about social interactions'
        }),
        ('Digest & Updates', {
            'fields': ('notify_weekly_digest', 'notify_updates', 'notify_marketing'),
            'description': 'Periodic emails and announcements'
        }),
        ('System', {
            'fields': ('unsubscribe_token', 'updated_at'),
            'classes': ('collapse',),
            'description': 'Internal system fields'
        }),
    )

    def delete_queryset(self, request, queryset):
        """
        Override bulk delete to add extra confirmation and warnings.

        CRITICAL: Deleting email preferences removes user's carefully
        configured notification settings. This should be very rare.
        """
        from django.contrib import messages

        count = queryset.count()

        # Always warn for bulk deletions
        if count > 1:
            messages.warning(
                request,
                f'‚ö†Ô∏è WARNING: You are about to delete {count} user email preferences. '
                f'This will permanently remove users\' notification settings. '
                f'Users will need to reconfigure their preferences. '
                f'Please confirm this is intentional and you have a backup.'
            )

        # Extra warning for large bulk deletions
        if count > 10:
            messages.error(
                request,
                f'üö® CRITICAL: Deleting {count} user preferences! '
                f'Have you created a backup? Run: python manage.py backup_email_preferences'
            )

        # Proceed with deletion (Django will show confirmation page)
        super().delete_queryset(request, queryset)

    def delete_model(self, request, obj):
        """
        Override single item delete to add warning.
        """
        from django.contrib import messages

        messages.warning(
            request,
            f'Deleted email preferences for user: {obj.user.username}. '
            f'User will need to reconfigure notification settings.'
        )

        super().delete_model(request, obj)

    class Meta:
        verbose_name = "Email Preference"
        verbose_name_plural = "‚ö†Ô∏è Email Preferences (User Data - Handle with Care)"


# =============================================================================
# COLLECTION ADMIN (Phase K)
# =============================================================================


class CollectionItemInline(admin.TabularInline):
    """Inline admin for collection items."""
    model = CollectionItem
    extra = 0
    raw_id_fields = ('prompt',)
    readonly_fields = ('added_at',)
    ordering = ('-added_at',)


@admin.register(Collection)
class CollectionAdmin(admin.ModelAdmin):
    """
    Admin configuration for Collection model.

    Features:
    - List view with item count, privacy status, soft delete status
    - Filter by privacy and deletion status
    - Search by title, username, email
    - Inline editing of collection items
    - Bulk actions for privacy and soft delete
    """
    list_display = (
        'title',
        'user',
        'item_count',
        'is_private',
        'is_deleted',
        'created_at',
        'updated_at',
    )
    list_filter = (
        'is_private',
        'is_deleted',
        'created_at',
    )
    search_fields = (
        'title',
        'user__username',
        'user__email',
    )
    list_select_related = ('user',)
    raw_id_fields = ('user', 'deleted_by')
    readonly_fields = ('created_at', 'updated_at', 'deleted_at', 'slug')
    prepopulated_fields = {}  # Don't prepopulate slug - it needs random suffix
    ordering = ('-updated_at',)
    date_hierarchy = 'created_at'
    inlines = [CollectionItemInline]
    list_per_page = 50
    actions = ['make_public', 'make_private', 'soft_delete_selected']

    fieldsets = (
        (None, {
            'fields': ('user', 'title', 'slug', 'is_private')
        }),
        ('Timestamps', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
        ('Soft Delete', {
            'fields': ('is_deleted', 'deleted_at', 'deleted_by'),
            'classes': ('collapse',)
        }),
    )

    def get_queryset(self, request):
        """Optimize queries with select_related and Count annotation."""
        from django.db.models import Count
        return super().get_queryset(request).annotate(
            _item_count=Count('items')
        ).select_related('user', 'deleted_by')

    @admin.display(description='Items', ordering='_item_count')
    def item_count(self, obj):
        """Display number of items in collection."""
        return getattr(obj, '_item_count', obj.items.count())

    # Bulk Actions
    def make_public(self, request, queryset):
        """Make selected collections public."""
        updated = queryset.update(is_private=False)
        self.message_user(request, f'{updated} collection(s) made public.')
    make_public.short_description = 'Make selected collections public'

    def make_private(self, request, queryset):
        """Make selected collections private."""
        updated = queryset.update(is_private=True)
        self.message_user(request, f'{updated} collection(s) made private.')
    make_private.short_description = 'Make selected collections private'

    def soft_delete_selected(self, request, queryset):
        """Soft delete selected collections."""
        from django.utils import timezone
        updated = queryset.update(
            is_deleted=True,
            deleted_at=timezone.now(),
            deleted_by=request.user
        )
        self.message_user(request, f'{updated} collection(s) moved to trash.')
    soft_delete_selected.short_description = 'Move to trash'


@admin.register(CollectionItem)
class CollectionItemAdmin(admin.ModelAdmin):
    """Admin configuration for CollectionItem model."""
    list_display = ('prompt', 'collection', 'added_at', 'order')
    list_filter = ('collection', 'added_at')
    search_fields = ('prompt__title', 'collection__title')
    list_select_related = ('collection', 'prompt')
    raw_id_fields = ('collection', 'prompt')
    readonly_fields = ('added_at',)
    ordering = ('-added_at',)
    list_per_page = 50


# ============================================================================
# TRASH & ORPHANED FILES DASHBOARD
# ============================================================================

from django.contrib.admin.views.decorators import staff_member_required
from django.shortcuts import render

@staff_member_required
def trash_dashboard(request):
    """
    Admin dashboard for trash bin and orphaned file management.

    Displays:
    - Count of deleted prompts
    - Count of orphaned images (Cloudinary files without prompts)
    - Count of orphaned videos
    - Recent deletions with restore options
    - Status of previously reported "ghost" prompts (149, 146, 145)
    """
    # Count deleted prompts (soft-deleted, in trash)
    deleted_count = Prompt.all_objects.filter(deleted_at__isnull=False).count()

    # Note: Orphaned file counts require Cloudinary API calls
    # For now, show placeholder counts (run detect_orphaned_files for real data)
    orphaned_images = 0  # Placeholder
    orphaned_videos = 0  # Placeholder

    # Get recent 10 deletions
    recent_deletions = Prompt.all_objects.filter(
        deleted_at__isnull=False
    ).select_related('author', 'deleted_by').order_by('-deleted_at')[:10]

    # Force fresh database query for ghost prompts
    ghost_ids = [149, 146, 145]
    ghost_info = []

    for prompt_id in ghost_ids:
        try:
            # Direct database query - no caching
            from django.db import connection
            with connection.cursor() as cursor:
                cursor.execute(
                    "SELECT id, title, status, featured_image, user_id FROM prompts_prompt WHERE id = %s",
                    [prompt_id]
                )
                row = cursor.fetchone()
                if row:
                    ghost_info.append({
                        'id': row[0],
                        'title': row[1][:50] if row[1] else 'No Title',
                        'status': 'Draft' if row[2] == 0 else 'Active',
                        'has_media': 'Yes' if row[3] else 'No',
                        'author': User.objects.get(id=row[4]).username if row[4] else 'Unknown'
                    })
        except Exception as e:
            print(f"Error with prompt {prompt_id}: {e}")

    # Get Django admin context for sidebar and logout button
    from django.contrib.admin.sites import site as admin_site
    context = admin_site.each_context(request)

    # Add custom context
    context.update({
        'deleted_count': deleted_count,
        'orphaned_images': orphaned_images,
        'orphaned_videos': orphaned_videos,
        'recent_deletions': recent_deletions,
        'ghost_prompts': ghost_info,
        'title': 'Trash & Orphaned Files Dashboard',
    })

    return render(request, 'admin/trash_dashboard.html', context)


@admin.register(SiteSettings)
class SiteSettingsAdmin(admin.ModelAdmin):
    """Admin interface for site-wide settings (singleton)."""
    list_display = (
        '__str__',
        'auto_approve_comments',
        'trending_recency_hours',
        'view_count_visibility'
    )
    fieldsets = (
        ('Comment Settings', {
            'fields': ('auto_approve_comments',),
            'description': 'Control how comments are handled on the site.'
        }),
        ('Trending Algorithm', {
            'fields': (
                'trending_like_weight',
                'trending_comment_weight',
                'trending_view_weight',
                'trending_recency_hours',
                'trending_gravity',
            ),
            'description': (
                'Configure the trending algorithm weights. '
                'Higher weights = more influence on trending score. '
                'Recency hours defines the "recent engagement" window. '
                'Gravity controls how quickly old content loses trending status.'
            ),
            'classes': ('collapse',),  # Collapsible for power users
        }),
        ('View Count Settings', {
            'fields': ('view_count_visibility', 'view_rate_limit'),
            'description': (
                'Control view count display and rate limiting. '
                'Visibility: Admin (staff only), Author (admin + owner), '
                'Premium (admin + subscribers), Public (everyone). '
                'Rate limit: Max views per minute per IP to prevent abuse.'
            ),
        }),
    )

    def has_add_permission(self, request):
        # Only allow one instance (singleton)
        return not SiteSettings.objects.exists()

    def has_delete_permission(self, request, obj=None):
        # Prevent deletion of settings
        return False


@admin.register(PromptView)
class PromptViewAdmin(admin.ModelAdmin):
    """Admin interface for viewing prompt views (read-only analytics)."""
    list_display = ('prompt', 'user', 'session_display', 'viewed_at')
    list_filter = ('viewed_at',)
    search_fields = ('prompt__title', 'user__username')
    readonly_fields = ('prompt', 'user', 'session_key', 'ip_hash', 'viewed_at')
    ordering = ('-viewed_at',)
    date_hierarchy = 'viewed_at'

    def session_display(self, obj):
        """Display truncated session key for anonymous users."""
        if obj.user:
            return '-'  # User is identified
        return obj.session_key[:8] + '...' if obj.session_key else '-'
    session_display.short_description = 'Session'

    def has_add_permission(self, request):
        # Views are recorded automatically, not manually added
        return False

    def has_change_permission(self, request, obj=None):
        # Views should be read-only
        return False


@admin.register(SlugRedirect)
class SlugRedirectAdmin(admin.ModelAdmin):
    list_display = ('old_slug', 'prompt', 'created_at')
    search_fields = ('old_slug', 'prompt__title')
    list_filter = ('created_at',)
    readonly_fields = ('created_at',)
    raw_id_fields = ('prompt',)

    def has_add_permission(self, request):
        return request.user.is_superuser

    def has_change_permission(self, request, obj=None):
        return request.user.is_superuser


# Set custom admin index template
admin.site.index_template = 'admin/custom_index.html'

