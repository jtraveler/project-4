{% extends "base.html" %}
{% load static %}
{% load cloudinary_tags %}

{% block extra_head %}
<!-- Only preload the FIRST image for true LCP optimization -->
{% with first_prompt=prompt_list.0 %}
    {% if first_prompt and not "placeholder" in first_prompt.featured_image.url %}
        <link rel="preload" as="image" href="{{ first_prompt.featured_image.url|cloudinary_transform:'w_440,f_webp,q_90' }}" />
    {% endif %}
{% endwith %}

<!-- Working Masonry with Columns -->
<style>
    .masonry-container {
        max-width: 100%;
        margin: 0;
        padding: 20px 40px;
        width: 100%;
    }
    
    /* Wrapper to contain the columns */
    .masonry-wrapper {
        position: relative;
        width: 100%;
    }
    
    /* Use flexbox for columns to maintain order */
    .masonry-grid {
        display: flex !important;
        gap: 15px;
        width: 100%;
        align-items: flex-start;
    }
    
    /* Individual columns */
    .masonry-column {
        flex: 1;
        display: flex !important;
        flex-direction: column;
        gap: 15px;
    }
    
    .masonry-item {
        width: 100% !important;
        margin-bottom: 0 !important;
        display: block !important;
        position: relative !important;
        float: none !important;
        opacity: 0;
        animation: fadeIn 0.5s ease forwards;
    }
    
    /* Ensure images load properly */
    .prompt-card {
        position: relative;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        background: #fff;
        width: 100%;
        height: fit-content;
    }

    .prompt-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    }

    .image-wrapper {
        position: relative;
        width: 100%;
    }

    .image-wrapper img {
        width: 100% !important;
        height: auto !important;
        display: block;
    }

    /* Admin Controls Styling */
    .admin-controls {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px 20px;
        margin: 20px 40px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    }

    .admin-controls h4 {
        margin: 0 0 10px 0;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .admin-controls p {
        margin: 0;
        opacity: 0.9;
        font-size: 14px;
    }

    .admin-controls .btn {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: white;
        font-size: 13px;
        padding: 5px 12px;
        margin-right: 8px;
        margin-top: 8px;
        border-radius: 5px;
        transition: all 0.3s ease;
    }

    .admin-controls .btn:hover {
        background: rgba(255, 255, 255, 0.3);
        border-color: rgba(255, 255, 255, 0.5);
        color: white;
        transform: translateY(-1px);
    }

    /* Admin overlay on cards */
    .admin-overlay {
        position: absolute;
        top: 8px;
        right: 8px;
        background: rgba(0, 0, 0, 0.8);
        border-radius: 5px;
        padding: 5px;
        z-index: 10;
        display: flex;
        gap: 3px;
    }

    .admin-overlay .btn {
        padding: 3px 6px;
        font-size: 11px;
        line-height: 1;
        min-width: auto;
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
    }

    .admin-overlay .btn:hover {
        background: rgba(255, 255, 255, 0.4);
        color: white;
    }

    /* Enhanced drag handle styling for better visibility */
    .drag-handle {
        position: absolute;
        top: 8px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 3px 8px;
        border-radius: 3px;
        font-size: 11px;
        cursor: grab;
        z-index: 15;
        display: none;
        user-select: none;
    }

    .drag-handle:active {
        cursor: grabbing;
    }

    .drag-handle.visible {
        display: block;
    }

    /* Enhanced dragging states with more prominent visual feedback */
    .masonry-item.dragging {
        opacity: 0.3;
        transform: rotate(5deg) scale(1.05);
        z-index: 1000;
        box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
    }

    .masonry-item.drag-over {
        transform: scale(1.05);
        border: 4px solid #667eea;
        border-radius: 12px;
        box-shadow: 0 0 30px rgba(102, 126, 234, 0.8);
        background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
        position: relative;
        animation: pulseGlow 0.8s ease-in-out infinite alternate;
    }

    /* Add "DROP HERE" text overlay */
    .masonry-item.drag-over::before {
        content: "DROP HERE";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(102, 126, 234, 0.9);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-weight: bold;
        font-size: 14px;
        z-index: 1000;
        pointer-events: none;
        animation: dropTextPulse 0.6s ease-in-out infinite alternate;
    }

    @keyframes pulseGlow {
        0% {
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.6);
        }
        100% {
            box-shadow: 0 0 40px rgba(102, 126, 234, 1);
        }
    }

    @keyframes dropTextPulse {
        0% {
            transform: translate(-50%, -50%) scale(1);
        }
        100% {
            transform: translate(-50%, -50%) scale(1.1);
        }
    }

    .drop-indicator {
        height: 4px;
        background: linear-gradient(90deg, #667eea, #764ba2);
        border-radius: 2px;
        margin: 8px 0;
        opacity: 0;
        transition: opacity 0.2s ease;
    }

    .drop-indicator.active {
        opacity: 1;
    }

    /* Sticky save button */
    .sticky-save-panel {
        position: fixed;
        top: 50%;
        right: 20px;
        transform: translateY(-50%);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        z-index: 1000;
        display: none;
        min-width: 180px;
        text-align: center;
    }

    .sticky-save-panel.visible {
        display: block;
        animation: slideInRight 0.3s ease;
    }

    .sticky-save-panel h5 {
        margin: 0 0 10px 0;
        font-size: 14px;
        font-weight: 600;
    }

    .sticky-save-panel .changes-count {
        font-size: 12px;
        opacity: 0.9;
        margin-bottom: 15px;
    }

    .sticky-save-panel .btn {
        background: rgba(255, 255, 255, 0.9);
        color: #333;
        border: none;
        padding: 8px 16px;
        border-radius: 5px;
        font-weight: 600;
        margin: 2px;
        transition: all 0.2s ease;
    }

    .sticky-save-panel .btn:hover {
        background: white;
        transform: translateY(-1px);
    }

    .sticky-save-panel .btn-save {
        background: #28a745;
        color: white;
    }

    .sticky-save-panel .btn-save:hover {
        background: #218838;
    }

    @keyframes slideInRight {
        from {
            transform: translateY(-50%) translateX(100%);
            opacity: 0;
        }
        to {
            transform: translateY(-50%) translateX(0);
            opacity: 1;
        }
    }

    .order-display {
        position: absolute;
        top: 8px;
        left: 8px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 3px 8px;
        border-radius: 3px;
        font-size: 11px;
        font-weight: bold;
        z-index: 10;
    }

    /* Video card styling */
    .video-card .image-wrapper {
    position: relative;
    background: transparent;
    }

    .gallery-video {
    width: 100%;
    height: auto;
    display: none;
    visibility: hidden;
    object-fit: contain;
    border-radius: 12px;
    position: relative;
    z-index: 2;
    }

    .video-thumbnail {
    width: 100%;
    height: auto;
    display: block;
    transition: opacity 0.3s ease;
    object-fit: contain;
    border-radius: 12px;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
    }

    .video-play-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 48px;
    color: rgba(255, 255, 255, 0.9);
    pointer-events: none;
    transition: opacity 0.3s ease;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    z-index: 3;
    }

    .video-card:hover .video-play-icon {
    transform: translate(-50%, -50%) scale(1.1);
    }

    /* Video in detail page */
    .hero-video {
    width: 100%;
    max-width: 100%;
    height: auto;
    border-radius: 1rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    margin: 0 auto;
    display: block;
    }

    /* Video loading state */
    .video-loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 24px;
    }


    /* Responsive */
    @media (max-width: 1100px) {
        .masonry-grid[data-columns="3"] .masonry-column:nth-child(4) {
            display: none !important;
        }
    }
    
    @media (max-width: 800px) {
        .masonry-grid[data-columns="2"] .masonry-column:nth-child(3),
        .masonry-grid[data-columns="2"] .masonry-column:nth-child(4) {
            display: none !important;
        }
    }

    /* Mobile-specific fix for video containers */
    @media (max-width: 768px) {
        .video-card .image-wrapper {
            position: relative;
            width: 100%;
        }
        
        .video-thumbnail {
            position: relative !important; /* Changed from absolute */
            width: 100%;
            height: auto;
            display: block;
            opacity: 1 !important;
        }
        
        .gallery-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: none !important;
        }

        .video-play-icon {
            z-index: 10;
            opacity: 1 !important;
        }

        .admin-controls {
            margin: 20px 20px;
            padding: 12px 15px;
        }

        .masonry-container {
            padding: 20px 20px;
        }
    }
    
    @media (max-width: 500px) {
        .masonry-grid[data-columns="1"] .masonry-column:nth-child(2),
        .masonry-grid[data-columns="1"] .masonry-column:nth-child(3),
        .masonry-grid[data-columns="1"] .masonry-column:nth-child(4) {
            display: none !important;
        }
    }

    /* Mobile padding fix for very small screens (iPhone SE, etc.) */
    @media (max-width: 400px) {
        .masonry-container {
            padding: 20px 12px;  /* Reduced from 20px to prevent horizontal scrollbar */
        }
    }

    /* Animation for items */
    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .masonry-item.new-item {
        animation: fadeIn 0.6s ease forwards;
    }
    
    /* Hide unused elements */
    .grid-sizer,
    .gutter-sizer {
        display: none !important;
    }
    
    /* End of results message */
    .end-of-results {
        padding: 40px 0;
    }

    .end-message {
        animation: fadeIn 0.6s ease forwards;
    }

    .end-message h3 {
        font-weight: 600;
        margin-bottom: 10px;
    }

    .end-message p {
        font-size: 1.1rem;
        margin-bottom: 0;
    }

    /* Placeholder image styling */
    .placeholder-image {
        background-color: #f0f0f0;
        object-fit: contain;
    }
</style>
{% endblock %}

{% block content %}
<h1 class="visually-hidden">PromptFlow - AI Prompt Gallery and Community</h1>

<!-- Hidden CSRF token for AJAX requests -->
<div style="display: none;">
    {% csrf_token %}
</div>

<!-- Admin Controls Panel (only visible to staff) -->
{% if user.is_staff and show_admin_controls %}
<div class="admin-controls">
    <h4>
        <i class="fas fa-cog"></i>
        Admin Ordering Controls
    </h4>
    <p>
        You can reorder prompts using the up/down arrows on each card, drag & drop mode, or edit order numbers directly in the 
        <a href="/admin/prompts/prompt/" target="_blank" style="color: #fff; text-decoration: underline;">Django Admin</a>.
        New prompts appear at the top by default.
    </p>
    <div>
        <a href="/admin/prompts/prompt/" target="_blank" class="btn btn-sm">
            <i class="fas fa-external-link-alt"></i> Open Admin Panel
        </a>
        <button onclick="toggleOrderDisplay()" class="btn btn-sm" id="toggle-order-btn">
            <i class="fas fa-eye"></i> Show Order Numbers
        </button>
        <button onclick="toggleDragMode()" class="btn btn-sm" id="toggle-drag-btn">
            <i class="fas fa-arrows-alt"></i> Drag Mode
        </button>
    </div>
</div>
{% endif %}

<!-- Media Filter Tabs (Phase E) -->
<style>
.media-filter-container {
    background: white;
    border-bottom: 1px solid #e5e7eb;
    padding: 0 40px;
    margin: 0 auto;
    margin-bottom: 0;
    max-width: 1600px;
}

.media-filter-tabs {
    display: flex;
    gap: 0;
}

.media-tab {
    padding: 12px 24px;
    background: none;
    border: none;
    border-bottom: 3px solid transparent;
    color: #6b7280;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    text-decoration: none;
}

.media-tab:hover {
    color: #1f2937;
    background: #f9fafb;
}

.media-tab.active {
    color: #1d4ed8;  /* Darker blue for WCAG AA contrast (4.5:1 minimum) */
    border-bottom-color: #1d4ed8;
}

@media (max-width: 768px) {
    .media-filter-container {
        padding: 0 20px;
    }

    .media-tab {
        flex: 1;
        padding: 12px 8px;
        font-size: 14px;
        text-align: center;
    }
}

/* Mobile padding fix for very small screens (iPhone SE, etc.) */
@media (max-width: 400px) {
    .media-filter-container {
        padding: 0 12px;  /* Reduced from 20px to prevent horizontal scrollbar */
    }
}
</style>

<div class="media-filter-container">
    <div class="media-filter-tabs" role="tablist" aria-label="Filter prompts by media type">
        <a href="{% url 'prompts:home' %}?media=all{% if current_tag %}&tag={{ current_tag }}{% endif %}{% if search_query %}&search={{ search_query }}{% endif %}"
           class="media-tab {% if media_filter == 'all' %}active{% endif %}"
           role="tab"
           aria-selected="{% if media_filter == 'all' %}true{% else %}false{% endif %}">
            All
        </a>
        <a href="{% url 'prompts:home' %}?media=photos{% if current_tag %}&tag={{ current_tag }}{% endif %}{% if search_query %}&search={{ search_query }}{% endif %}"
           class="media-tab {% if media_filter == 'photos' %}active{% endif %}"
           role="tab"
           aria-selected="{% if media_filter == 'photos' %}true{% else %}false{% endif %}">
            <i class="fas fa-image"></i> Photos
        </a>
        <a href="{% url 'prompts:home' %}?media=videos{% if current_tag %}&tag={{ current_tag }}{% endif %}{% if search_query %}&search={{ search_query }}{% endif %}"
           class="media-tab {% if media_filter == 'videos' %}active{% endif %}"
           role="tab"
           aria-selected="{% if media_filter == 'videos' %}true{% else %}false{% endif %}">
            <i class="fas fa-video"></i> Videos
        </a>
    </div>
</div>

<!-- Tag Filter Header -->
{% if current_tag %}
<div class="tag-filter-header">
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-md-8 text-center">
                <h2 class="tag-title">
                    Showing prompts tagged with: <span class="tag-name">"{{ current_tag }}"</span>
                </h2>
                <p class="tag-subtitle">{{ page_obj.paginator.count }} prompt{{ page_obj.paginator.count|pluralize }} found</p>
                <a href="{% url 'prompts:home' %}#browse-prompts" class="btn btn-outline-primary btn-sm">
                    <i class="fas fa-arrow-left me-1"></i> Show all prompts
                </a>
            </div>
        </div>
    </div>
</div>
{% endif %}

<!-- Enhanced Search Results Header -->
{% if search_query %}
<div class="tag-filter-header">
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-md-10 text-center">
                <h2 class="tag-title">
                    <i class="fas fa-search me-2"></i>Search results for: <span class="tag-name">"{{ search_query }}"</span>
                </h2>
                <p class="tag-subtitle">
                    {{ page_obj.paginator.count }} prompt{{ page_obj.paginator.count|pluralize }} found
                    {% if page_obj.paginator.count > 0 %}
                        <br>
                        <small class="text-muted">
                            Searched in: titles, content, descriptions, authors, and tags
                        </small>
                    {% endif %}
                </p>
                <div class="search-actions mt-3">
                    <a href="{% url 'prompts:home' %}#browse-prompts" class="btn btn-outline-primary btn-sm">
                        <i class="fas fa-arrow-left me-1"></i> Show all prompts
                    </a>
                </div>
            </div>
        </div>
    </div>
</div>
{% endif %}

<!-- Check if we have prompts to show -->
{% if prompt_list %}
<!-- Optimized masonry grid -->
<div class="masonry-container">
    <div class="masonry-wrapper">
        <div class="masonry-grid" id="masonry-grid">
            <!-- Columns will be created by JavaScript -->
        </div>
    </div>
    
    <!-- Store items in a hidden container for JavaScript to process -->
    <div id="items-container" style="display: none;">
        {% for prompt in prompt_list %}
            {% include 'prompts/partials/_prompt_card.html' with prompt=prompt show_trash_actions=False show_admin_controls=True %}
        {% endfor %}
    </div>
    
    <!-- Load More Button -->
    {% if page_obj.has_next %}
    <div class="load-more-container text-center mt-5 mb-5">
        <button id="load-more-btn"
                class="btn btn-primary btn-lg"
                data-next-page="{{ page_obj.next_page_number }}"
                aria-label="Load more prompts">
            <i class="fas fa-plus-circle me-2"></i>
            Load More Prompts
        </button>
    </div>
    {% else %}
    <!-- End of results message -->
    <div class="end-of-results text-center mt-5">
        <div class="end-message">
            <i class="fas fa-check-circle text-muted mb-3" style="font-size: 3rem;"></i>
            <h3 class="text-muted">You have reached the end.</h3>
            <p class="text-muted">No more prompts to load</p>
        </div>
    </div>
    {% endif %}
</div>
{% else %}
<!-- No results message - Outside masonry container -->
<div class="container">
    <div class="row justify-content-center">
        <div class="col-md-6 text-center py-5">
            <h2 class="text-muted mb-3">No prompts found</h2>
            <p class="text-muted">Try adjusting your search or browse all prompts</p>
        </div>
    </div>
</div>
{% endif %}

<!-- Sticky Save Panel (only visible to staff when changes are made) -->
{% if user.is_staff %}
<div class="sticky-save-panel" id="sticky-save-panel">
    <h5><i class="fas fa-save me-2"></i>Unsaved Changes</h5>
    <div class="changes-count" id="changes-count">0 items reordered</div>
    <div>
        <button onclick="saveOrderChanges()" class="btn btn-save">
            <i class="fas fa-check me-1"></i>Save Changes
        </button>
        <button onclick="cancelOrderChanges()" class="btn">
            <i class="fas fa-times me-1"></i>Cancel
        </button>
    </div>
</div>
{% endif %}
{% endblock %}

{% block extras %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Masonry column management
    let columns = [];
    let columnCount = 4;
    let videoObserver = null;
    
    function getColumnCount() {
        const width = window.innerWidth;
        if (width < 500) return 1;
        if (width < 800) return 2;
        if (width < 1100) return 3;
        return 4;
    }
    
    function createColumns() {
        const grid = document.getElementById('masonry-grid');
        grid.innerHTML = '';
        columns = [];
        
        const newColumnCount = getColumnCount();
        grid.setAttribute('data-columns', newColumnCount);
        
        for (let i = 0; i < 4; i++) { // Always create 4 columns, CSS will hide extras
            const column = document.createElement('div');
            column.className = 'masonry-column';
            column.id = `column-${i}`;
            grid.appendChild(column);
            columns.push(column);
        }
        
        columnCount = newColumnCount;
    }
    
    function getShortestColumn() {
        let shortest = columns[0];
        let minHeight = shortest.offsetHeight;
        
        for (let i = 0; i < columnCount; i++) {
            if (columns[i].offsetHeight < minHeight) {
                minHeight = columns[i].offsetHeight;
                shortest = columns[i];
            }
        }
        
        return shortest;
    }
    
    // Find the shortest column starting from a specific index
    function getShortestColumnFrom(startIndex) {
        let shortestIndex = startIndex;
        let minHeight = columns[startIndex].offsetHeight;
        
        // Check columns in order from startIndex
        for (let i = startIndex; i < columnCount; i++) {
            if (columns[i].offsetHeight < minHeight) {
                minHeight = columns[i].offsetHeight;
                shortestIndex = i;
            }
        }
        
        // If we didn't find a shorter column to the right, check from the beginning
        for (let i = 0; i < startIndex; i++) {
            if (columns[i].offsetHeight < minHeight) {
                minHeight = columns[i].offsetHeight;
                shortestIndex = i;
            }
        }
        
        return columns[shortestIndex];
    }

    /**
     * FORCED EQUAL DISTRIBUTION - For initial page load only
     * Distributes items as evenly as possible across columns
     */
    function forceEqualDistribution(items) {
        const currentColumns = Array.from(document.querySelectorAll('.masonry-column'));
        
        if (currentColumns.length === 0) {
            console.error('No columns found for redistribution');
            return;
        }
        
        // Clear all columns
        currentColumns.forEach(column => column.innerHTML = '');
        
        const activeColumns = currentColumns.slice(0, columnCount);
        const itemsPerColumn = Math.ceil(items.length / columnCount);
        
        console.log(`Equal distribution: ${items.length} items across ${columnCount} columns (max ${itemsPerColumn} items per column)`);
        
        // Distribute items evenly - each column gets roughly the same number
        let currentColumnIndex = 0;
        let itemsInCurrentColumn = 0;
        
        items.forEach((item, index) => {
            // If current column is full, move to next column
            if (itemsInCurrentColumn >= itemsPerColumn && currentColumnIndex < columnCount - 1) {
                currentColumnIndex++;
                itemsInCurrentColumn = 0;
            }
            
            activeColumns[currentColumnIndex].appendChild(item);
            itemsInCurrentColumn++;
            
            console.log(`Item ${index + 1} -> Column ${currentColumnIndex + 1} (${itemsInCurrentColumn}/${itemsPerColumn})`);
        });
        
        // Log final distribution
        activeColumns.forEach((column, index) => {
            console.log(`Column ${index + 1}: ${column.children.length} items`);
        });
    }

    /**
     * HYBRID REDISTRIBUTION - For drag operations
     * Provides immediate visual feedback while maintaining reasonable balance
     */
    function hybridRedistribution(items) {
        const currentColumns = Array.from(document.querySelectorAll('.masonry-column'));
        
        if (currentColumns.length === 0) {
            console.error('No columns found for redistribution');
            return;
        }
        
        // Clear all columns
        currentColumns.forEach(column => column.innerHTML = '');
        const activeColumns = currentColumns.slice(0, columnCount);
        
        console.log('Hybrid redistribution: respects drag order with balance limits');
        
        // Track column stats
        const columnStats = activeColumns.map((column, index) => ({
            element: column,
            itemCount: 0,
            index: index
        }));
        
        const maxItemsPerColumn = Math.ceil(items.length / columnCount) + 1; // Allow some flexibility
        
        items.forEach((item, index) => {
            // First preference: shortest column (for visual balance)
            let targetColumnIndex = 0;
            let minItems = columnStats[0].itemCount;
            
            for (let i = 0; i < columnCount; i++) {
                if (columnStats[i].itemCount < minItems) {
                    minItems = columnStats[i].itemCount;
                    targetColumnIndex = i;
                }
            }
            
            // If shortest column is getting too full, use round-robin
            if (columnStats[targetColumnIndex].itemCount >= maxItemsPerColumn) {
                targetColumnIndex = index % columnCount;
            }
            
            // Add item to selected column
            const targetColumn = columnStats[targetColumnIndex];
            targetColumn.element.appendChild(item);
            targetColumn.itemCount++;
            
            console.log(`Item ${index + 1} -> Column ${targetColumnIndex + 1} (${targetColumn.itemCount} items)`);
        });
        
        // Log final distribution
        columnStats.forEach((stat) => {
            console.log(`Column ${stat.index + 1}: ${stat.itemCount} items`);
        });
        
        // Re-enable dragging if drag mode is active
        if (typeof dragModeEnabled !== 'undefined' && dragModeEnabled) {
            items.forEach(item => enableDragging(item));
        }
        
        // Reinitialize video observer
        initVideoObserver();
    }

    // FIXED distribute items function - hybrid approach for different scenarios
    function distributeItems(items, animate = false, preferLeftToRight = false) {
        console.log(`distributeItems called with ${items.length} items, animate: ${animate}, preferLeftToRight: ${preferLeftToRight}`);
        
        if (preferLeftToRight) {
            // For "Load More" items, use the original left-to-right logic to append naturally
            // This preserves the smooth load more UX without rebuilding the entire grid
            console.log('Using original append logic for load more items');
            
            // Simple left-to-right distribution for load more
            let currentColumnIndex = 0;
            
            items.forEach((item, index) => {
                if (animate) {
                    item.classList.add('new-item');
                    item.style.animationDelay = `${index * 0.1}s`;
                }
                
                // Add to current column and move to next
                columns[currentColumnIndex].appendChild(item);
                currentColumnIndex = (currentColumnIndex + 1) % columnCount;
                
                console.log(`Load more item ${index + 1} -> Column ${currentColumnIndex}`);
            });
        } else {
            // For initial load only, use equal distribution for better balance
            console.log('Using equal distribution for initial load');
            forceEqualDistribution(items);
            
            // Apply animations if requested
            if (animate) {
                items.forEach((item, index) => {
                    item.classList.add('new-item');
                    item.style.animationDelay = `${index * 0.1}s`;
                });
            }
        }
        
        // Initialize video observer after items are distributed
        initVideoObserver();
    }


    /**
     * Lazy-loads video content by setting the source URL only when needed.
     * This improves page load performance by deferring video loading until
     * the video enters the viewport.
     * 
     * @param {HTMLVideoElement} video - The video element to load
     * @returns {void} Early returns if video is already loaded
     */
    function loadVideoSource(video) {
        if (video.dataset.loaded === 'true') return;
        
        const source = video.querySelector('source');
        if (source && source.dataset.src) {
            source.src = source.dataset.src;
            video.load();
            video.dataset.loaded = 'true';
        }
    }

// Video auto-play functionality with lazy loading

function initVideoObserver() {
    if (videoObserver) {
        videoObserver.disconnect();
    }
    
    const videoCards = document.querySelectorAll('[data-video="true"]');
    
    if (videoCards.length === 0) return;
    
    // Check if mobile or prefers reduced motion
    const isMobile = window.innerWidth <= 768;
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    
    if (isMobile || prefersReducedMotion) {
        return; // Skip video autoplay on mobile or reduced motion preference
    }
    
    // Percentage-based offsets
    const PAUSE_OFFSET_PERCENT = 0.5; // 50% of video height must be visible
    const PLAY_OFFSET_PERCENT = 0.3;  // 30% of video height
    
    // Store play promises to handle them properly
    const playPromises = new WeakMap();
    
    videoObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            const video = entry.target.querySelector('video');
            const thumbnail = entry.target.querySelector('.video-thumbnail');
            const playIcon = entry.target.querySelector('.video-play-icon');
            
            if (!video) return;
            
            // Get the element's position relative to viewport
            const rect = entry.boundingClientRect;
            const viewportHeight = window.innerHeight;
            const elementHeight = rect.height;
            
            // Calculate dynamic offsets based on element height
            const playOffset = elementHeight * PLAY_OFFSET_PERCENT;
            
            // Check if video is already initialized
            const isInitialized = video.dataset.initialized === 'true';
            
            if (entry.isIntersecting && entry.intersectionRatio > 0.3) {
                // Check if we should play based on percentage offsets
                const topInView = rect.top < viewportHeight - playOffset;
                const bottomInView = rect.bottom > playOffset;
                const shouldPlay = topInView && bottomInView;
                
                if (shouldPlay || !isInitialized) {
                    // Load video source if not already loaded
                    loadVideoSource(video);
                    
                    // First time setup - show video once
                    if (!isInitialized) {
                        video.style.display = 'block';
                        video.style.visibility = 'visible';
                        video.dataset.initialized = 'true';
                    }
                    
                    // Only play if not already playing
                    if (video.paused) {
                        if (thumbnail) thumbnail.style.opacity = '0';
                        if (playIcon) playIcon.style.opacity = '0';
                        
                        // Store and handle the play promise properly
                        const playPromise = video.play();
                        
                        if (playPromise !== undefined) {
                            playPromises.set(video, playPromise);
                            
                            playPromise
                                .then(() => {
                                    // Playback started successfully
                                    playPromises.delete(video);
                                })
                                .catch(error => {
                                    // Only log if it's not an AbortError
                                    if (error.name !== 'AbortError') {
                                        console.log('Auto-play prevented:', error);
                                        if (thumbnail) thumbnail.style.opacity = '1';
                                        if (playIcon) playIcon.style.opacity = '1';
                                    }
                                    playPromises.delete(video);
                                });
                        }
                    }
                }
            }
            
            // Always check pause conditions for initialized videos
            if (isInitialized) {
                // Calculate how much is visible when scrolling out
                const topVisible = rect.top >= 0 && rect.top < viewportHeight;
                const bottomVisible = rect.bottom > 0 && rect.bottom <= viewportHeight;
                
                let shouldPause = false;
                
                if (!entry.isIntersecting) {
                    shouldPause = true;
                } else if (topVisible && !bottomVisible) {
                    // Scrolling up, video going out bottom
                    const visiblePortion = (viewportHeight - rect.top) / elementHeight;
                    shouldPause = visiblePortion < PAUSE_OFFSET_PERCENT;
                } else if (!topVisible && bottomVisible) {
                    // Scrolling down, video going out top
                    const visiblePortion = rect.bottom / elementHeight;
                    shouldPause = visiblePortion < PAUSE_OFFSET_PERCENT;
                }
                
                if (shouldPause && !video.paused) {
                    // Wait for any pending play promise before pausing
                    const currentPlayPromise = playPromises.get(video);
                    
                    if (currentPlayPromise) {
                        currentPlayPromise.then(() => {
                            video.pause();
                        }).catch(() => {
                            // Ignore the error, video wasn't playing anyway
                        });
                    } else {
                        video.pause();
                    }
                }
            }
        });
    }, {
        threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1],
        rootMargin: '0px'
    });
    
    videoCards.forEach(card => {
        videoObserver.observe(card);
    });
    
    // Force initial check for videos already in view
    setTimeout(() => {
        videoCards.forEach(card => {
            const rect = card.getBoundingClientRect();
            const video = card.querySelector('video');
            const thumbnail = card.querySelector('.video-thumbnail');
            const playIcon = card.querySelector('.video-play-icon');
            
            if (rect.top < window.innerHeight && rect.bottom > 0 && video) {
                // Video is in view on load
                loadVideoSource(video);
                video.style.display = 'block';
                video.style.visibility = 'visible';
                video.dataset.initialized = 'true';
                
                if (thumbnail) thumbnail.style.opacity = '0';
                if (playIcon) playIcon.style.opacity = '0';
                
                const playPromise = video.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        if (error.name !== 'AbortError') {
                            console.log('Initial auto-play prevented:', error);
                            if (thumbnail) thumbnail.style.opacity = '1';
                            if (playIcon) playIcon.style.opacity = '1';
                        }
                    });
                }
            }
        });
    }, 500);
}
    
    // Initialize columns
    createColumns();
    
    // Distribute initial items
    const itemsContainer = document.getElementById('items-container');
    const initialItems = Array.from(itemsContainer.querySelectorAll('[data-item]'));
    distributeItems(initialItems, false, false);
    
    // Heart functionality
    function attachHeartFunctionality(container = document) {
        const likeSections = container.querySelectorAll('.like-section');
        
        likeSections.forEach(function(section) {
            if (section.dataset.listenerAttached) return;
            
            section.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const promptSlug = this.getAttribute('data-prompt-slug');
                const heartIcon = this.querySelector('i');
                const likeCount = this.querySelector('.like-count');
                const likePlural = this.querySelector('.like-plural');
                
                fetch('/prompt/' + promptSlug + '/like/', {
                    method: 'POST',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                        'Content-Type': 'application/json',
                    },
                })
                .then(response => response.json())
                .then(data => {
                    likeCount.textContent = data.like_count;
                    likePlural.textContent = data.like_count === 1 ? '' : 's';
                    heartIcon.className = data.liked ? 'fas fa-heart me-1' : 'far fa-heart me-1';
                    heartIcon.style.color = 'white';
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Something went wrong. Please try again.');
                });
            });
            
            section.dataset.listenerAttached = 'true';
        });
    }
    
    attachHeartFunctionality();
    
    // Load More functionality
    const loadMoreBtn = document.getElementById('load-more-btn');

    if (loadMoreBtn) {
        loadMoreBtn.addEventListener('click', function() {
            const nextPage = this.getAttribute('data-next-page');
            const currentUrl = window.location.pathname;
            const currentParams = new URLSearchParams(window.location.search);
            currentParams.set('page', nextPage);

            // Disable button and show loading state (prevents jumping)
            loadMoreBtn.disabled = true;
            loadMoreBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Loading More Prompts...';
            loadMoreBtn.style.pointerEvents = 'none';  // Prevent additional clicks
            
            // Hide all order numbers temporarily if they're currently visible
            const wasOrderVisible = orderDisplayVisible;
            if (wasOrderVisible) {
                // Just hide numbers, don't toggle the state
                document.querySelectorAll('.order-display').forEach(display => {
                    display.style.display = 'none';
                });
            }
            
            fetch(`${currentUrl}?${currentParams.toString()}`)
                .then(response => response.text())
                .then(html => {
                    const parser = new DOMParser();
                    const newDoc = parser.parseFromString(html, 'text/html');
                    const newItems = Array.from(newDoc.querySelectorAll('[data-item]'));
                    
                    // Distribute new items with left-to-right preference
                    distributeItems(newItems, true, true);
                    
                    // Attach heart functionality to new items
                    attachHeartFunctionality();
                    
                    // Apply drag functionality to new items if drag mode is enabled
                    if (dragModeEnabled) {
                        newItems.forEach(item => {
                            enableDragging(item);
                            // Show drag handles for new items
                            const dragHandle = item.querySelector('.drag-handle');
                            if (dragHandle) {
                                dragHandle.classList.add('visible');
                            }
                        });
                    }
                    
                    // Show order numbers again if they were visible before
                    if (wasOrderVisible) {
                        setTimeout(() => {
                            // Force show all order displays including new ones
                            document.querySelectorAll('.order-display').forEach(display => {
                                display.style.display = 'block';
                            });
                            orderDisplayVisible = true;
                            
                            // Update button text
                            const toggleBtn = document.getElementById('toggle-order-btn');
                            if (toggleBtn) {
                                toggleBtn.innerHTML = '<i class="fas fa-eye-slash"></i> Hide Order Numbers';
                            }
                        }, 300);
                    }
                    
                    // Update load more button
                    const newLoadMoreBtn = newDoc.getElementById('load-more-btn');
                    if (newLoadMoreBtn) {
                        // More pages available - restore button
                        loadMoreBtn.setAttribute('data-next-page',
                            newLoadMoreBtn.getAttribute('data-next-page'));
                        loadMoreBtn.disabled = false;
                        loadMoreBtn.innerHTML = '<i class="fas fa-plus-circle me-2"></i>Load More Prompts';
                        loadMoreBtn.style.pointerEvents = 'auto';
                    } else {
                        // No more pages - replace with end message
                        const loadMoreContainer = document.querySelector('.load-more-container');
                        if (loadMoreContainer) {
                            loadMoreContainer.innerHTML = `
                                <div class="end-of-results text-center">
                                    <div class="end-message">
                                        <i class="fas fa-check-circle text-muted mb-3" style="font-size: 3rem;"></i>
                                        <h3 class="text-muted">You have reached the end.</h3>
                                        <p class="text-muted">No more prompts to load</p>
                                    </div>
                                </div>
                            `;
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading more prompts:', error);
                    // Restore button on error
                    loadMoreBtn.disabled = false;
                    loadMoreBtn.innerHTML = '<i class="fas fa-plus-circle me-2"></i>Load More Prompts';
                    loadMoreBtn.style.pointerEvents = 'auto';
                    // Show error message to user
                    alert('Failed to load more prompts. Please try again.');
                });
        });
    }
    
    // Tag filtering
    const tagBadges = document.querySelectorAll('.tag-clickable');
    tagBadges.forEach(function(badge) {
        badge.addEventListener('click', function() {
            const tagName = this.getAttribute('data-tag');
            const url = window.location.origin;
            window.location.href = `${url}/?tag=${encodeURIComponent(tagName)}`;
        });
    });
    
    // Handle window resize
    let resizeTimer;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(function() {
            if (getColumnCount() !== columnCount) {
                // Collect all items
                const allItems = [];
                columns.forEach(column => {
                    const items = Array.from(column.querySelectorAll('.masonry-item'));
                    allItems.push(...items);
                });
                
                // Recreate columns and redistribute
                createColumns();
                distributeItems(allItems, false, false);
            }
        }, 250);
    });
});


    /**
     * Redistribution for drag operations - provides immediate visual feedback
     */
     function redistributeItems() {
        // Collect all items and sort by order (this maintains drag order)
        const allItems = Array.from(document.querySelectorAll('.masonry-item'))
            .sort((a, b) => parseFloat(a.dataset.order) - parseFloat(b.dataset.order));
        
        console.log('Redistributing items after drag operation for immediate visual feedback...');
        
        // Get current column setup
        const currentColumns = Array.from(document.querySelectorAll('.masonry-column'));
        const activeColumnCount = currentColumns.filter(col => col.offsetParent !== null).length;
        
        console.log(`Total items: ${allItems.length}, Active columns: ${activeColumnCount}`);
        
        // Clear all columns first
        currentColumns.forEach(column => column.innerHTML = '');
        const activeColumns = currentColumns.slice(0, activeColumnCount);
        
        // Use simple round-robin distribution that respects the new order
        allItems.forEach((item, index) => {
            const targetColumnIndex = index % activeColumnCount;
            activeColumns[targetColumnIndex].appendChild(item);
            
            console.log(`Item ${index + 1} (order: ${item.dataset.order}) -> Column ${targetColumnIndex + 1}`);
        });
        
        // Re-enable dragging if drag mode is active
        if (typeof dragModeEnabled !== 'undefined' && dragModeEnabled) {
            allItems.forEach(item => enableDragging(item));
        }
        
        console.log('Drag redistribution complete - items should be in new visual positions');
    }


// Admin control functions (only available to staff)
{% if user.is_staff %}
let orderDisplayVisible = false;
let dragModeEnabled = false;
let pendingChanges = new Map(); // Map to store slug -> new order
let originalOrder = new Map(); // Map to store original order values

function toggleOrderDisplay() {
    const orderDisplays = document.querySelectorAll('.order-display');
    const toggleBtn = document.getElementById('toggle-order-btn');
    orderDisplayVisible = orderDisplays[0]?.style.display !== 'none';
    
    orderDisplays.forEach(display => {
        display.style.display = orderDisplayVisible ? 'none' : 'block';
    });
    
    // Update global state
    orderDisplayVisible = !orderDisplayVisible;
    
    if (toggleBtn) {
        const icon = toggleBtn.querySelector('i');
        const text = orderDisplayVisible ? 'Hide Order Numbers' : 'Show Order Numbers';
        toggleBtn.innerHTML = `<i class="fas fa-eye${orderDisplayVisible ? '-slash' : ''}"></i> ${text}`;
    }
}

function toggleDragMode() {
    dragModeEnabled = !dragModeEnabled;
    const toggleBtn = document.getElementById('toggle-drag-btn');
    const dragHandles = document.querySelectorAll('.drag-handle');
    
    dragHandles.forEach(handle => {
        handle.classList.toggle('visible', dragModeEnabled);
    });
    
    if (toggleBtn) {
        const icon = toggleBtn.querySelector('i');
        const text = dragModeEnabled ? 'Exit Drag Mode' : 'Drag Mode';
        const iconClass = dragModeEnabled ? 'fa-times' : 'fa-arrows-alt';
        toggleBtn.innerHTML = `<i class="fas ${iconClass}"></i> ${text}`;
        toggleBtn.style.background = dragModeEnabled ? 'rgba(220, 53, 69, 0.3)' : 'rgba(255, 255, 255, 0.2)';
    }
    
    // Enable/disable dragging
    const masonryItems = document.querySelectorAll('.masonry-item');
    masonryItems.forEach(item => {
        if (dragModeEnabled) {
            enableDragging(item);
        } else {
            disableDragging(item);
        }
    });
    
    // Show/hide order numbers automatically in drag mode
    if (dragModeEnabled && !orderDisplayVisible) {
        toggleOrderDisplay();
    }
}

// ENHANCED DRAG FUNCTIONALITY WITH BETTER VISUAL FEEDBACK
function enableDragging(item) {
    item.setAttribute('draggable', 'true');
    
    // Add event listeners to the item itself, not just the handle
    item.addEventListener('dragstart', handleDragStart);
    item.addEventListener('dragover', handleDragOver);
    item.addEventListener('drop', handleDrop);
    item.addEventListener('dragend', handleDragEnd);
    item.addEventListener('dragenter', handleDragEnter);
    item.addEventListener('dragleave', handleDragLeave);
}

function disableDragging(item) {
    item.setAttribute('draggable', 'false');
    item.removeEventListener('dragstart', handleDragStart);
    item.removeEventListener('dragover', handleDragOver);
    item.removeEventListener('drop', handleDrop);
    item.removeEventListener('dragend', handleDragEnd);
    item.removeEventListener('dragenter', handleDragEnter);
    item.removeEventListener('dragleave', handleDragLeave);
}

function handleDragStart(e) {
    if (!dragModeEnabled) return;
    
    const item = e.currentTarget;
    item.classList.add('dragging');
    e.dataTransfer.setData('text/plain', item.dataset.slug);
    e.dataTransfer.effectAllowed = 'move';
    
    // Store original order if not already stored
    if (!originalOrder.has(item.dataset.slug)) {
        originalOrder.set(item.dataset.slug, parseFloat(item.dataset.order));
    }
    
    console.log('Drag started for:', item.dataset.slug);
}

function handleDragEnter(e) {
    if (!dragModeEnabled) return;
    e.preventDefault();
}

function handleDragOver(e) {
    if (!dragModeEnabled) return;
    
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    const item = e.currentTarget;
    if (item && !item.classList.contains('dragging')) {
        item.classList.add('drag-over');
    }
}

function handleDragLeave(e) {
    if (!dragModeEnabled) return;
    
    const item = e.currentTarget;
    if (item) {
        item.classList.remove('drag-over');
    }
}

function handleDrop(e) {
    if (!dragModeEnabled) return;
    
    e.preventDefault();
    const draggedSlug = e.dataTransfer.getData('text/plain');
    const targetItem = e.currentTarget;
    const draggedItem = document.querySelector(`[data-slug="${draggedSlug}"]`);
    
    console.log('Drop event:', { draggedSlug, targetItem: targetItem.dataset.slug });
    
    if (targetItem && draggedItem && targetItem !== draggedItem) {
        // Calculate new order number
        const targetOrder = parseFloat(targetItem.dataset.order);
        
        // Determine if dropping above or below
        const rect = targetItem.getBoundingClientRect();
        const dropY = e.clientY;
        const targetCenter = rect.top + rect.height / 2;
        const isDroppedBelow = dropY > targetCenter;
        
        let newOrder;
        if (isDroppedBelow) {
            // Find next item's order to calculate between
            const nextOrder = getNextOrderAfter(targetOrder);
            newOrder = nextOrder ? (targetOrder + nextOrder) / 2 : targetOrder + 1;
        } else {
            // Find previous item's order to calculate between
            const prevOrder = getPreviousOrderBefore(targetOrder);
            newOrder = prevOrder ? (prevOrder + targetOrder) / 2 : targetOrder - 1;
        }
        
        console.log('New order calculated:', newOrder);
        
        // Update the order
        updateItemOrder(draggedSlug, newOrder);
        
        // Visual update
        draggedItem.dataset.order = newOrder;
        const orderDisplay = draggedItem.querySelector('.order-display');
        if (orderDisplay) {
            orderDisplay.textContent = newOrder.toFixed(1);
        }
        
        // Use the redistributeItems function from the correct scope
        if (typeof redistributeItems === 'function') {
            redistributeItems();
        } else {
            console.error('redistributeItems function not found in scope');
            // Fallback: force a page refresh to show changes
            location.reload();
        }
    }
    
    // Clean up
    document.querySelectorAll('.drag-over').forEach(item => {
        item.classList.remove('drag-over');
    });
}

function handleDragEnd(e) {
    const item = e.currentTarget;
    if (item) {
        item.classList.remove('dragging');
    }
    
    document.querySelectorAll('.drag-over').forEach(item => {
        item.classList.remove('drag-over');
    });
}

function getNextOrderAfter(order) {
    const items = Array.from(document.querySelectorAll('.masonry-item'))
        .map(item => parseFloat(item.dataset.order))
        .filter(o => o > order)
        .sort((a, b) => a - b);
    return items[0] || null;
}

function getPreviousOrderBefore(order) {
    const items = Array.from(document.querySelectorAll('.masonry-item'))
        .map(item => parseFloat(item.dataset.order))
        .filter(o => o < order)
        .sort((a, b) => b - a);
    return items[0] || null;
}

function updateItemOrder(slug, newOrder) {
    pendingChanges.set(slug, newOrder);
    updateSavePanel();
    console.log('Pending changes:', Array.from(pendingChanges.entries()));
}

function updateSavePanel() {
    const savePanel = document.getElementById('sticky-save-panel');
    const changesCount = document.getElementById('changes-count');
    
    if (pendingChanges.size > 0) {
        savePanel.classList.add('visible');
        changesCount.textContent = `${pendingChanges.size} item${pendingChanges.size !== 1 ? 's' : ''} reordered`;
    } else {
        savePanel.classList.remove('visible');
    }
}

function saveOrderChanges() {
    if (pendingChanges.size === 0) return;
    
    const saveBtn = document.querySelector('.btn-save');
    const originalText = saveBtn.innerHTML;
    saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Saving...';
    saveBtn.disabled = true;
    
    // Convert Map to array for AJAX
    const changes = Array.from(pendingChanges.entries()).map(([slug, order]) => ({
        slug: slug,
        order: order
    }));
    
    console.log('Saving changes:', changes);
    console.log('CSRF Token:', document.querySelector('[name=csrfmiddlewaretoken]').value);
    
    fetch('/prompts-admin/bulk-reorder/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
        },
        body: JSON.stringify({ changes: changes })
    })
    .then(response => {
        console.log('Response status:', response.status);
        console.log('Response headers:', response.headers);
        
        if (!response.ok) {
            return response.text().then(text => {
                console.error('Response text:', text);
                throw new Error(`HTTP ${response.status}: ${text}`);
            });
        }
        
        return response.json();
    })
    .then(data => {
        console.log('Save response:', data);
        if (data.success) {
            // Clear pending changes
            pendingChanges.clear();
            originalOrder.clear();
            updateSavePanel();
            
            // Show success message
            showMessage('Order saved successfully!', 'success');
        } else {
            throw new Error(data.error || 'Failed to save order');
        }
    })
    .catch(error => {
        console.error('Full error details:', error);
        showMessage('Failed to save order. Check console for details.', 'error');
    })
    .finally(() => {
        saveBtn.innerHTML = originalText;
        saveBtn.disabled = false;
    });
}

function cancelOrderChanges() {
    // Restore original orders
    pendingChanges.forEach((newOrder, slug) => {
        const item = document.querySelector(`[data-slug="${slug}"]`);
        const originalOrderValue = originalOrder.get(slug);
        
        if (item && originalOrderValue !== undefined) {
            item.dataset.order = originalOrderValue;
            const orderDisplay = item.querySelector('.order-display');
            if (orderDisplay) {
                orderDisplay.textContent = originalOrderValue;
            }
        }
    });
    
    // Clear changes
    pendingChanges.clear();
    originalOrder.clear();
    updateSavePanel();
    
    // Redistribute items with hybrid algorithm
    redistributeItems();
    
    showMessage('Changes cancelled', 'info');
}

function showMessage(text, type) {
    // Simple message display
    const message = document.createElement('div');
    message.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        background: ${type === 'success' ? '#28a745' : type === 'error' ? '#dc3545' : '#17a2b8'};
        color: white;
        border-radius: 5px;
        z-index: 10000;
        font-weight: 500;
    `;
    message.textContent = text;
    document.body.appendChild(message);
    
    setTimeout(() => {
        message.remove();
    }, 3000);
}

{% else %}
let orderDisplayVisible = false;

function toggleOrderDisplay() {
    // Simplified version for non-staff users
    const orderDisplays = document.querySelectorAll('.order-display');
    const toggleBtn = document.getElementById('toggle-order-btn');
    orderDisplayVisible = orderDisplays[0]?.style.display !== 'none';
    
    orderDisplays.forEach(display => {
        display.style.display = orderDisplayVisible ? 'none' : 'block';
    });
    
    orderDisplayVisible = !orderDisplayVisible;
    
    if (toggleBtn) {
        const icon = toggleBtn.querySelector('i');
        const text = orderDisplayVisible ? 'Hide Order Numbers' : 'Show Order Numbers';
        toggleBtn.innerHTML = `<i class="fas fa-eye${orderDisplayVisible ? '-slash' : ''}"></i> ${text}`;
    }
}
{% endif %}

function applyOrderDisplayState() {
    // Apply current visibility state to all order displays (including newly loaded ones)
    const orderDisplays = document.querySelectorAll('.order-display');
    orderDisplays.forEach(display => {
        display.style.display = orderDisplayVisible ? 'block' : 'none';
    });
}
</script>
{% endblock %}